{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tileverse","text":"<p>Tileverse provides a toolkit of independent Java libraries for building cloud-native geospatial applications. </p> <p>These libraries are designed to be composable: pick the ones you need for your specific problem\u2014whether that's reading from cloud storage, handling vector tiles, or calculating tile grids\u2014without pulling in a monolithic framework.</p>"},{"location":"#libraries","title":"Libraries","text":"Library Artifact Role Range Reader <code>tileverse-rangereader-all</code> I/O Abstraction: Unified API for efficient byte-range access across S3, Azure, GCS, HTTP, and local files. PMTiles <code>tileverse-pmtiles</code> Archive Format: Read/write support for PMTiles v3, leveraging Range Reader for cloud access. Vector Tiles <code>tileverse-vectortiles</code> Codec: High-performance encoding and decoding of Mapbox Vector Tiles (MVT) to/from JTS Geometries. Tile Matrix Set <code>tileverse-tilematrixset</code> Math &amp; Logic: Implementation of the OGC Tile Matrix Set standard for calculating tile pyramids and grids."},{"location":"#ecosystem","title":"Ecosystem","text":"<p>While <code>tileverse-pmtiles</code> naturally uses the other libraries, Range Reader, Vector Tiles, and Tile Matrix Set are completely standalone. </p> <ul> <li>Building a tile server from PostGIS? Use Vector Tiles and Tile Matrix Set.</li> <li>Reading COGs (Cloud Optimized GeoTIFFs)? Use Range Reader.</li> <li>Need a standard grid definition? Use Tile Matrix Set.</li> </ul> <pre><code>graph TD\n    App[Your App]\n\n    subgraph \"I/O\"\n        RR[Range Reader]\n    end\n\n    subgraph \"Formats\"\n        VT[Vector Tiles]\n        PMT[PMTiles]\n    end\n\n    subgraph \"Spatial\"\n        TMS[Tile Matrix Set]\n    end\n\n    App --&gt; RR\n    App --&gt; VT\n    App --&gt; PMT\n    App --&gt; TMS\n\n    PMT -.-&gt; RR\n    PMT -.-&gt; VT\n    PMT -.-&gt; TMS</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Tileverse is available on Maven Central. You can use the Bill of Materials (BOM) to manage versions across all modules.</p> MavenGradle <p>Add the BOM to your <code>dependencyManagement</code> to ensure version consistency:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0.0&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre> <p>Then add specific modules to your <code>dependencies</code> block:</p> <pre><code>&lt;dependencies&gt;\n    &lt;!-- Efficient data access (File, HTTP, S3, etc.) --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- PMTiles support --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>dependencies {\n    implementation(platform(\"io.tileverse:tileverse-bom:1.0.0\"))\n\n    implementation(\"io.tileverse.rangereader:tileverse-rangereader-all\")\n    implementation(\"io.tileverse.pmtiles:tileverse-pmtiles\")\n}\n</code></pre>"},{"location":"getting-started/#version-compatibility","title":"Version Compatibility","text":"Library Version Java Version Maven Version 1.0.x 17+ 3.9+"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#reading-a-pmtiles-archive","title":"Reading a PMTiles Archive","text":"<p>This example demonstrates how to read a PMTiles file from a local path using the <code>FileRangeReader</code>.</p> <pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\npublic class Example {\n    public void readTile() throws Exception {\n        // Initialize the underlying data source\n        var source = FileRangeReader.builder()\n            .path(Path.of(\"data/planet.pmtiles\"))\n            .build();\n\n        // Open the PMTiles reader\n        try (var reader = new PMTilesReader(source::asByteChannel)) {\n            // Fetch a specific tile (z=0, x=0, y=0)\n            Optional&lt;ByteBuffer&gt; tile = reader.getTile(0, 0, 0);\n\n            tile.ifPresent(buffer -&gt; {\n                buffer.flip(); // Important: flip the buffer before reading\n                System.out.println(\"Found tile: \" + buffer.remaining() + \" bytes\");\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#cloud-storage-access","title":"Cloud Storage Access","text":"<p>To access files on S3, swap the <code>FileRangeReader</code> for <code>S3RangeReader</code>. The upper-level <code>PMTilesReader</code> API remains unchanged.</p> <pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\nimport java.net.URI;\n\nvar s3Source = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/maps/planet.pmtiles\"))\n    .region(Region.US_EAST_1)\n    .build();\n\n// Wrap with caching for performance\nvar cachedSource = CachingRangeReader.builder(s3Source)\n    .capacity(50_000_000) // 50MB cache\n    .build();\n\nvar reader = new PMTilesReader(cachedSource::asByteChannel);\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Java 17 or later.</li> <li>Maven 3.8+ or Gradle 7+.</li> </ul>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>Welcome to the Tileverse Developer Guide. This section provides everything you need to contribute to the project, build from source, and understand the testing infrastructure.</p>"},{"location":"developer-guide/#contents","title":"Contents","text":"<ul> <li>Building: How to compile and package the project.</li> <li>Testing: Running unit, integration, and performance tests.</li> <li>Contributing: Code style, pull request process, and contribution guidelines.</li> <li>Architecture: High-level system design and module relationships.</li> </ul>"},{"location":"developer-guide/#core-principles","title":"Core Principles","text":"<ul> <li>Modularity: Libraries are designed to work independently.</li> <li>Cloud-Native: First-class support for S3, Azure, GCS, and HTTP.</li> <li>Performance: Heavy focus on zero-copy I/O and efficient memory usage.</li> <li>Standards: Strict adherence to OGC and Mapbox specifications.</li> </ul>"},{"location":"developer-guide/building/","title":"Building","text":"<p>Instructions for building the Tileverse monorepo from source.</p>"},{"location":"developer-guide/building/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 21+: For development (the runtime requirement is Java 17+).</li> <li>Maven 3.9+: Build tool and dependency management.</li> <li>Git: Version control.</li> <li>Docker: Required for running integration tests (Testcontainers).</li> </ul>"},{"location":"developer-guide/building/#quick-start","title":"Quick Start","text":""},{"location":"developer-guide/building/#using-the-makefile-recommended","title":"Using the Makefile (Recommended)","text":"<p>The project includes a <code>Makefile</code> to simplify common tasks:</p> <pre><code># Build everything (compile + test)\nmake\n\n# Clean build artifacts\nmake clean\n\n# Compile only\nmake compile\n\n# Run all tests\nmake test\n\n# Format code (Spotless + SortPOM)\nmake format\n</code></pre>"},{"location":"developer-guide/building/#using-maven-directly","title":"Using Maven Directly","text":"<pre><code># Build and package\n./mvnw clean package\n\n# Skip tests for faster build\n./mvnw clean package -DskipTests\n</code></pre>"},{"location":"developer-guide/building/#build-targets","title":"Build Targets","text":""},{"location":"developer-guide/building/#module-specific-builds","title":"Module Specific Builds","text":"<p>You can build specific modules to save time:</p> <pre><code># Build Range Reader only\n./mvnw clean package -pl tileverse-rangereader\n\n# Build PMTiles only\n./mvnw clean package -pl tileverse-pmtiles\n</code></pre>"},{"location":"developer-guide/building/#code-quality","title":"Code Quality","text":"<p>We enforce strict code quality standards using:</p> <ul> <li>Spotless: For Java code formatting (Palantir style).</li> <li>SortPOM: For consistent <code>pom.xml</code> ordering.</li> <li>License Maven Plugin: To ensure file headers are present.</li> </ul> <pre><code># Check code quality\nmake lint\n\n# Apply fixes automatically\nmake format\n</code></pre>"},{"location":"developer-guide/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Tileverse! We welcome contributions from the community to help build the best Java ecosystem for cloud-native geospatial data.</p>"},{"location":"developer-guide/contributing/#code-contribution-process","title":"Code Contribution Process","text":"<ol> <li>Fork &amp; Clone: Fork the repo and clone it locally.</li> <li>Branch: Create a feature branch (<code>feat/my-feature</code> or <code>fix/my-bug</code>).</li> <li>Code: Implement your changes.</li> <li>Test: Add unit tests for new logic and ensure existing tests pass.</li> <li>Format: Run <code>make format</code> to ensure code style compliance.</li> <li>PR: Submit a Pull Request to the <code>main</code> branch.</li> </ol>"},{"location":"developer-guide/contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Java Version: Target Java 17 compatibility, but build with Java 21+.</li> <li>Style: We use the Palantir Java Style.</li> <li>Javadoc: Public APIs must be documented.</li> <li>Null Safety: Use <code>Optional&lt;T&gt;</code> for return types that might be missing. Avoid returning <code>null</code>.</li> </ul>"},{"location":"developer-guide/contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Unit Tests: Required for all new logic.</li> <li>Integration Tests: Required for cloud provider interactions (S3, Azure, GCS).</li> <li>Performance Tests: Required if modifying critical I/O paths.</li> </ul>"},{"location":"developer-guide/contributing/#commit-messages","title":"Commit Messages","text":"<p>We follow the Conventional Commits specification:</p> <ul> <li><code>feat: add GCS support</code></li> <li><code>fix: handle EOF correctly in range reader</code></li> <li><code>docs: update usage examples</code></li> <li><code>chore: bump dependencies</code></li> </ul>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":"<p>Releases are automated via GitHub Actions.</p> <ul> <li>Snapshots: Published on every merge to <code>main</code>.</li> <li>Releases: Published when a new tag (e.g., <code>v1.0.0</code>) is pushed.</li> </ul>"},{"location":"developer-guide/testing/","title":"Testing","text":"<p>This guide covers the testing strategy for the Tileverse project.</p>"},{"location":"developer-guide/testing/#overview","title":"Overview","text":"<p>We use a tiered testing approach:</p> <ol> <li>Unit Tests: Fast, in-memory tests using JUnit 5 and Mockito.</li> <li>Integration Tests: Docker-based tests using Testcontainers to verify interactions with real services (S3, Azure, GCS, HTTP).</li> <li>Benchmarks: JMH microbenchmarks for critical paths.</li> </ol>"},{"location":"developer-guide/testing/#running-tests","title":"Running Tests","text":""},{"location":"developer-guide/testing/#unit-tests","title":"Unit Tests","text":"<pre><code>make test-unit\n# OR\n./mvnw test\n</code></pre>"},{"location":"developer-guide/testing/#integration-tests","title":"Integration Tests","text":"<p>Requires Docker to be running.</p> <pre><code>make test-it\n# OR\n./mvnw verify\n</code></pre>"},{"location":"developer-guide/testing/#specific-modules","title":"Specific Modules","text":"<pre><code># Run tests for PMTiles only\n./mvnw test -pl tileverse-pmtiles\n\n# Run S3 integration tests\n./mvnw verify -pl tileverse-rangereader/s3\n</code></pre>"},{"location":"developer-guide/testing/#test-infrastructure","title":"Test Infrastructure","text":""},{"location":"developer-guide/testing/#testcontainers","title":"Testcontainers","text":"<p>We use specific images to emulate cloud environments:</p> <ul> <li>AWS S3: <code>localstack/localstack</code></li> <li>Azure Blob: <code>mcr.microsoft.com/azure-storage/azurite</code></li> <li>GCS: <code>fsouza/fake-gcs-server</code></li> <li>HTTP: <code>nginx:alpine</code></li> </ul>"},{"location":"developer-guide/testing/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Benchmarks are located in the <code>tileverse-rangereader/benchmarks</code> module.</p> <pre><code># Build benchmarks\nmake build-benchmarks\n\n# Run\nmake benchmarks\n</code></pre>"},{"location":"developer-guide/architecture/","title":"System Architecture","text":"<p>Tileverse is designed as a collection of loosely coupled, composable libraries. While they work seamlessly together, each module acts as a standalone tool for its specific domain (I/O, Tiling, Encodings).</p>"},{"location":"developer-guide/architecture/#component-relationships","title":"Component Relationships","text":"<p>The following diagram illustrates how the libraries relate to user applications and each other. Note that <code>pmtiles</code> is the only module that strictly depends on others (<code>rangereader</code> for I/O and <code>vectortiles</code> for decoding).</p> <pre><code>graph TD\n    subgraph \"Application Layer\"\n        App[User Application]\n    end\n\n    subgraph \"Independent Modules\"\n        RR[tileverse-rangereader]\n        VT[tileverse-vectortiles]\n        TMS[tileverse-tilematrixset]\n    end\n\n    subgraph \"Composed Modules\"\n        PMT[tileverse-pmtiles]\n    end\n\n    App --&gt; RR\n    App --&gt; VT\n    App --&gt; TMS\n    App --&gt; PMT\n\n    PMT --&gt; RR\n    PMT --&gt; VT\n    PMT --&gt; TMS</code></pre>"},{"location":"developer-guide/architecture/#design-philosophy","title":"Design Philosophy","text":""},{"location":"developer-guide/architecture/#1-io-independence-rangereader","title":"1. I/O Independence (<code>rangereader</code>)","text":"<p>We treat data access as a distinct problem from data format. </p> <ul> <li>Goal: Read bytes from anywhere (S3, HTTP, Azure, File) efficiently.</li> <li>Anti-Pattern: Format libraries (like a GeoTIFF reader) implementing their own S3 clients.</li> <li>Solution: <code>RangeReader</code> provides a unified <code>readRange(start, length)</code> interface.</li> </ul>"},{"location":"developer-guide/architecture/#2-pure-mathematical-models-tilematrixset","title":"2. Pure Mathematical Models (<code>tilematrixset</code>)","text":"<p>Spatial reference systems and grid logic are kept separate from data storage.</p> <ul> <li>Goal: Calculate tile coordinates and bounding boxes without external dependencies.</li> <li>Benefit: Can be used by a tile server to calculate grids even if the data source isn't Java-based or uses a different I/O library.</li> </ul>"},{"location":"developer-guide/architecture/#3-format-specificity-vectortiles-pmtiles","title":"3. Format Specificity (<code>vectortiles</code>, <code>pmtiles</code>)","text":"<p>These libraries handle the parsing and encoding logic for specific file specs.</p> <ul> <li>Vector Tiles: Pure Protocol Buffers / JTS transcoding. No I/O logic.</li> <li>PMTiles: Orchestrates <code>RangeReader</code> to fetch specific directory bytes, uses <code>VectorTiles</code> to parse the result, and <code>TileMatrixSet</code> to understand the grid.</li> </ul>"},{"location":"developer-guide/architecture/#integration-patterns","title":"Integration Patterns","text":""},{"location":"developer-guide/architecture/#direct-usage","title":"Direct Usage","text":"<p>Applications often use modules directly:</p> <ul> <li>ETL Pipelines: Use <code>vectortiles</code> to convert PostGIS geometry to MVT bytes.</li> <li>Tile Servers: Use <code>tilematrixset</code> to calculate which tiles cover a viewport.</li> <li>Data Access: Use <code>rangereader</code> to fetch partial content from Cloud Optimized GeoTIFFs (COGs) stored on S3.</li> </ul>"},{"location":"developer-guide/architecture/#composed-usage","title":"Composed Usage","text":"<p>The <code>pmtiles</code> library demonstrates the power of composition:</p> <ol> <li>Accepts a <code>RangeReader</code> interface (polymorphic backend).</li> <li>Uses <code>HilbertCurve</code> (internal) for index lookup.</li> <li>Returns raw bytes or uses <code>vectortiles</code> to return parsed geometry.</li> </ol>"},{"location":"developer-guide/architecture/dependencies/","title":"Module Dependencies","text":"<p>Tileverse aims to minimize transitive dependencies while leveraging established libraries for core functionality.</p>"},{"location":"developer-guide/architecture/dependencies/#core-dependencies","title":"Core Dependencies","text":"Library Usage Module JTS Topology Suite Geometry model (Points, Polygons, etc.) <code>vectortiles</code>, <code>pmtiles</code> Caffeine High-performance in-memory caching <code>rangereader</code> Jackson JSON parsing (metadata, configurations) <code>pmtiles</code> Google Protocol Buffers MVT binary encoding/decoding <code>vectortiles</code> SLF4J Logging abstraction All"},{"location":"developer-guide/architecture/dependencies/#optional-dependencies","title":"Optional Dependencies","text":"<p>These are only required if you use specific features (e.g., cloud storage).</p> Library Usage Module AWS SDK for Java v2 S3 Range Reader <code>rangereader-s3</code> Azure SDK for Java Azure Blob Range Reader <code>rangereader-azure</code> Google Cloud Java GCS Range Reader <code>rangereader-gcs</code> Apache Commons Compress Zstd compression support <code>pmtiles</code>"},{"location":"developer-guide/architecture/system-design/","title":"System Design","text":""},{"location":"developer-guide/architecture/system-design/#data-flow-architecture","title":"Data Flow Architecture","text":"<p>Tileverse allows applications to stream tiled data from remote storage directly to the client (or processing engine) with minimal memory overhead.</p>"},{"location":"developer-guide/architecture/system-design/#1-request-lifecycle","title":"1. Request Lifecycle","text":"<p>When a <code>PMTilesReader</code> requests a tile <code>(z, x, y)</code>:</p> <ol> <li>Spatial Index Lookup: The reader calculates the Hilbert ID for the requested tile.</li> <li>Directory Fetch: It checks if the relevant directory section is in memory. If not, it issues a byte-range request to the <code>RangeReader</code>.</li> <li>Offset Calculation: Using the directory data, it finds the exact byte offset and length of the tile data in the archive.</li> <li>Data Fetch: It issues a second byte-range request to the <code>RangeReader</code> for the actual tile body.</li> <li>Decoding: The raw bytes are passed to the <code>VectorTileCodec</code> (if MVT) or returned as-is (if Raster).</li> </ol>"},{"location":"developer-guide/architecture/system-design/#2-caching-strategy","title":"2. Caching Strategy","text":"<p>To avoid network latency, the <code>CachingRangeReader</code> implements a two-tier cache:</p> <ul> <li>Tier 1 (Metadata): PMTiles directories and headers are highly cacheable and small. They are prioritized in the \"Meta\" cache.</li> <li>Tier 2 (Data): Actual tile data is cached in a separate \"Data\" cache (optional), useful for hot areas of the map.</li> </ul>"},{"location":"developer-guide/architecture/system-design/#3-extensibility","title":"3. Extensibility","text":"<p>The system is designed for extension via interfaces:</p> <ul> <li>Implement <code>RangeReader</code> to support a new storage backend (e.g., Hadoop HDFS, FTP).</li> <li>Implement <code>TileMatrixSet</code> to support exotic non-Earth coordinate systems.</li> </ul>"},{"location":"pmtiles/","title":"PMTiles","text":"<p>This module provides a pure Java implementation of the PMTiles v3 specification, a single-file archive format for cloud-optimized tiled data.</p>"},{"location":"pmtiles/#features","title":"Features","text":"<ul> <li>Read &amp; Write: Full support for creating and consuming PMTiles archives.</li> <li>Storage Agnostic: Works seamlessly with any Range Reader backend (S3, HTTP, Local File).</li> <li>Spatial Indexing: Implements Hilbert curve indexing for O(log N) tile lookups.</li> <li>Type Support: Handles both vector (MVT) and raster (PNG, JPG, WebP) tiles.</li> </ul>"},{"location":"pmtiles/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pmtiles/#usage","title":"Usage","text":""},{"location":"pmtiles/#reading","title":"Reading","text":"<p>The <code>PMTilesReader</code> accepts a <code>Supplier&lt;SeekableByteChannel&gt;</code>. The <code>RangeReader</code> can provide this via its <code>asByteChannel()</code> method.</p> <pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\n\nvar source = FileRangeReader.builder()\n    .path(Path.of(\"data/map.pmtiles\"))\n    .build();\n\ntry (var reader = new PMTilesReader(source::asByteChannel)) {\n    // Get metadata\n    var header = reader.getHeader();\n    System.out.println(\"Min Zoom: \" + header.minZoom());\n\n    // Fetch tile (z, x, y)\n    reader.getTile(0, 0, 0).ifPresent(buffer -&gt; {\n        buffer.flip(); // Important: flip the buffer before reading\n        // Process tile bytes...\n    });\n}\n</code></pre>"},{"location":"pmtiles/#writing","title":"Writing","text":"<p>Writing involves the <code>PMTilesWriter</code> which organizes input data into the proper directory structure with Hilbert ordering.</p> <pre><code>var writer = new PMTilesWriter(outputStream);\n\n// Add tiles (order doesn't matter, writer handles sorting)\nwriter.addTile(0, 0, 0, tileBytes);\n\n// Finalize and write directory\nwriter.finish();\n</code></pre>"},{"location":"pmtiles/user-guide/","title":"PMTiles User Guide","text":"<p>Welcome to the Tileverse PMTiles User Guide. This guide will help you understand and use the PMTiles library effectively.</p>"},{"location":"pmtiles/user-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers:</p> <ul> <li>Quick Start: Get up and running quickly</li> <li>Reading PMTiles: Read tiles from PMTiles archives</li> <li>Writing PMTiles: Create new PMTiles archives</li> <li>Cloud Storage: Work with PMTiles in S3, Azure, and GCS</li> </ul>"},{"location":"pmtiles/user-guide/#installation","title":"Installation","text":"<p>Add the PMTiles dependency to your project:</p> MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Also add a Range Reader provider --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies {\n    implementation 'io.tileverse.pmtiles:tileverse-pmtiles:1.1-SNAPSHOT'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.1-SNAPSHOT'\n}\n</code></pre>"},{"location":"pmtiles/user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"pmtiles/user-guide/#pmtiles-structure","title":"PMTiles Structure","text":"<p>A PMTiles archive contains:</p> <ol> <li>Header: Metadata about the tileset (bounds, zoom levels, tile format)</li> <li>Directory: Spatial index using Hilbert curves</li> <li>Tiles: Compressed tile data</li> </ol>"},{"location":"pmtiles/user-guide/#tile-addressing","title":"Tile Addressing","text":"<p>Tiles are addressed using the standard XYZ scheme:</p> <ul> <li>z: Zoom level (0 = world view, higher = more detailed)</li> <li>x: Column number (west to east)</li> <li>y: Row number (north to south in TMS, south to north in XYZ)</li> </ul>"},{"location":"pmtiles/user-guide/#data-sources","title":"Data Sources","text":"<p>PMTiles can be read from any source supported by Range Reader:</p> <ul> <li>Local files</li> <li>HTTP/HTTPS servers</li> <li>Amazon S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> </ul>"},{"location":"pmtiles/user-guide/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Begin with a simple example</li> <li>Reading PMTiles: Learn about reading tiles</li> <li>Cloud Storage: Access PMTiles from the cloud</li> </ul>"},{"location":"pmtiles/user-guide/cloud-storage/","title":"Cloud Storage Integration","text":"<p>Learn how to efficiently access PMTiles from cloud storage providers.</p>"},{"location":"pmtiles/user-guide/cloud-storage/#overview","title":"Overview","text":"<p>PMTiles is designed to work efficiently with cloud object storage. By using HTTP range requests, you can serve tiles directly from S3, Azure Blob Storage, or Google Cloud Storage without a specialized tile server.</p>"},{"location":"pmtiles/user-guide/cloud-storage/#amazon-s3","title":"Amazon S3","text":""},{"location":"pmtiles/user-guide/cloud-storage/#basic-s3-access","title":"Basic S3 Access","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\n\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/world.pmtiles\"))\n    .region(Region.US_WEST_2)\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(s3Reader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#with-caching","title":"With Caching","text":"<pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\nRangeReader cachedReader = CachingRangeReader.builder(s3Reader)\n    .maximumSize(1000)\n    .withBlockAlignment()\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(cachedReader::asByteChannel)) {\n    // Cached reads\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#azure-blob-storage","title":"Azure Blob Storage","text":"<pre><code>import io.tileverse.rangereader.azure.AzureBlobRangeReader;\n\nRangeReader azureReader = AzureBlobRangeReader.builder()\n    .connectionString(connectionString)\n    .containerName(\"tiles\")\n    .blobPath(\"world.pmtiles\")\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(azureReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#google-cloud-storage","title":"Google Cloud Storage","text":"<pre><code>import io.tileverse.rangereader.gcs.GoogleCloudStorageRangeReader;\n\nRangeReader gcsReader = GoogleCloudStorageRangeReader.builder()\n    .uri(URI.create(\"gs://my-bucket/world.pmtiles\"))\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(gcsReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"pmtiles/user-guide/cloud-storage/#multi-level-caching","title":"Multi-Level Caching","text":"<p>Combine memory and disk caching for optimal performance:</p> <pre><code>// Disk cache\nRangeReader diskCached = DiskCachingRangeReader.builder(s3Reader)\n    .cacheDirectory(Path.of(\"/tmp/tile-cache\"))\n    .maximumCacheSize(10_000_000_000L)  // 10 GB\n    .build();\n\n// Memory cache on top\nRangeReader memoryCached = CachingRangeReader.builder(diskCached)\n    .maximumSize(1000)\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(memoryCached::asByteChannel)) {\n    // Optimized access\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#block-alignment","title":"Block Alignment","text":"<p>Use block-aligned reads to minimize cloud storage requests:</p> <pre><code>RangeReader alignedReader = BlockAlignedRangeReader.builder(s3Reader)\n    .blockSize(65536)  // 64 KB blocks\n    .build();\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#cost-optimization","title":"Cost Optimization","text":"<ol> <li>Enable caching to reduce request counts</li> <li>Use CDN in front of object storage</li> <li>Choose appropriate storage class (Standard vs. Infrequent Access)</li> <li>Monitor request patterns and adjust caching strategy</li> </ol>"},{"location":"pmtiles/user-guide/cloud-storage/#see-also","title":"See Also","text":"<ul> <li>Range Reader Authentication</li> <li>Range Reader Performance</li> </ul>"},{"location":"pmtiles/user-guide/quick-start/","title":"PMTiles Quick Start","text":"<p>Get started with Tileverse PMTiles in under 5 minutes.</p>"},{"location":"pmtiles/user-guide/quick-start/#installation","title":"Installation","text":"<p>First, add the dependencies:</p> MavenGradle <pre><code>&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>dependencies {\n    implementation 'io.tileverse.pmtiles:tileverse-pmtiles:1.1-SNAPSHOT'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.1-SNAPSHOT'\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-tiles-from-a-local-file","title":"Reading Tiles from a Local File","text":"<pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.pmtiles.PMTilesHeader;\nimport io.tileverse.rangereader.RangeReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\npublic class QuickStart {\n    public static void main(String[] args) throws Exception {\n        // Create a range reader for the PMTiles file\n        RangeReader rangeReader = FileRangeReader.builder()\n            .path(Path.of(\"world.pmtiles\"))\n            .build();\n\n        // Open the PMTiles archive\n        try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n            // Read the header to get metadata\n            PMTilesHeader header = reader.getHeader();\n            System.out.println(\"Tile Format: \" + header.tileType());\n            System.out.println(\"Min Zoom: \" + header.minZoom());\n            System.out.println(\"Max Zoom: \" + header.maxZoom());\n\n            // Get a specific tile (zoom=10, x=885, y=412)\n            Optional&lt;ByteBuffer&gt; tileData = reader.getTile(10, 885, 412);\n\n            if (tileData.isPresent()) {\n                System.out.printf(\"Tile found! Size: %d bytes%n\",\n                    tileData.get().remaining());\n            } else {\n                System.out.println(\"Tile not found\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-from-http","title":"Reading from HTTP","text":"<pre><code>import io.tileverse.rangereader.http.HttpRangeReader;\n\n// Create HTTP range reader\nRangeReader httpReader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://example.com/tiles.pmtiles\"))\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(httpReader::asByteChannel)) {\n    Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);\n    // Process tile...\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-from-s3","title":"Reading from S3","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\n\n// Create S3 range reader\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/world.pmtiles\"))\n    .region(Region.US_WEST_2)\n    .build();\n\n    try (PMTilesReader reader = new PMTilesReader(s3Reader::asByteChannel)) {\n        Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);    // Process tile...\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#with-caching","title":"With Caching","text":"<p>For better performance, especially with cloud storage, add caching:</p> <pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\n// Wrap the base reader with caching\nRangeReader cachedReader = CachingRangeReader.builder(s3Reader)\n    .maximumSize(1000)  // Cache up to 1000 ranges\n    .withBlockAlignment()  // Optimize reads\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(cachedReader::asByteChannel)) {\n    // Subsequent reads will be cached\n    Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#processing-multiple-tiles","title":"Processing Multiple Tiles","text":"<pre><code>// Get tiles for a specific area\nint zoom = 10;\nint minX = 880, maxX = 890;\nint minY = 410, maxY = 420;\n\ntry (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    for (int x = minX; x &lt;= maxX; x++) {\n        for (int y = minY; y &lt;= maxY; y++) {\n            Optional&lt;ByteBuffer&gt; tile = reader.getTile(zoom, x, y);\n            if (tile.isPresent()) {\n                System.out.printf(\"Tile %d/%d/%d: %d bytes%n\",\n                    zoom, x, y, tile.get().remaining());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Reading PMTiles: Learn more about reading operations</li> <li>Writing PMTiles: Create your own PMTiles archives</li> <li>Cloud Storage: Deep dive into cloud storage integration</li> <li>Range Reader Guide: Understand the underlying data access layer</li> </ul>"},{"location":"pmtiles/user-guide/reading/","title":"Reading PMTiles","text":"<p>This guide covers advanced topics for reading PMTiles archives.</p>"},{"location":"pmtiles/user-guide/reading/#opening-pmtiles-archives","title":"Opening PMTiles Archives","text":"<p>PMTiles archives can be opened from any data source supported by Range Reader:</p> <pre><code>// Local file\nRangeReader fileReader = FileRangeReader.builder()\n    .path(Path.of(\"tiles.pmtiles\"))\n    .build();\n\n// HTTP\nRangeReader httpReader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://example.com/tiles.pmtiles\"))\n    .build();\n\n// S3\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/tiles.pmtiles\"))\n    .build();\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#reading-header-information","title":"Reading Header Information","text":"<p>The header contains essential metadata about the tileset:</p> <pre><code>try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    PMTilesHeader header = reader.getHeader();\n\n    // Tile format (MVT, PNG, JPEG, WEBP, etc.)\n    String tileType = header.tileType();\n\n    // Zoom level range\n    int minZoom = header.minZoom();\n    int maxZoom = header.maxZoom();\n\n    // Geographic bounds (in E7 format: degrees * 10,000,000)\n    double minLon = header.minLonE7() / 10_000_000.0;\n    double minLat = header.minLatE7() / 10_000_000.0;\n    double maxLon = header.maxLonE7() / 10_000_000.0;\n    double maxLat = header.maxLatE7() / 10_000_000.0;\n\n    System.out.printf(\"Bounds: [%.6f, %.6f, %.6f, %.6f]%n\",\n        minLon, minLat, maxLon, maxLat);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#reading-individual-tiles","title":"Reading Individual Tiles","text":"<p>Tiles are retrieved using the standard Z/X/Y addressing:</p> <pre><code>Optional&lt;ByteBuffer&gt; tileData = reader.getTile(zoom, x, y);\n\nif (tileData.isPresent()) {\n    ByteBuffer tile = tileData.get();\n    tile.flip(); // Important: flip the buffer before reading\n    // Process tile data...\n} else {\n    // Tile doesn't exist in the archive\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#bulk-tile-operations","title":"Bulk Tile Operations","text":""},{"location":"pmtiles/user-guide/reading/#reading-a-tile-range","title":"Reading a Tile Range","text":"<pre><code>int zoom = 10;\nfor (int x = 880; x &lt;= 890; x++) {\n    for (int y = 410; y &lt;= 420; y++) {\n                    Optional&lt;ByteBuffer&gt; tile = reader.getTile(zoom, x, y);\n                    if (tile.isPresent()) {\n                        tile.get().flip(); // Flip before processing\n                        processTile(zoom, x, y, tile.get());        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#parallel-processing","title":"Parallel Processing","text":"<p>PMTilesReader is thread-safe for read operations:</p> <pre><code>IntStream.range(880, 891)\n    .parallel()\n    .forEach(x -&gt; {\n        IntStream.range(410, 421).forEach(y -&gt; {\n            reader.getTile(zoom, x, y).ifPresent(buffer -&gt; {\n                buffer.flip();\n                processTile(zoom, x, y, buffer);\n            });\n        });\n    });\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use caching for cloud storage sources</li> <li>Enable block alignment for optimal read patterns</li> <li>Reuse readers instead of creating new instances</li> <li>Batch operations when processing multiple tiles</li> </ol> <p>See Cloud Storage for detailed performance optimization strategies.</p>"},{"location":"pmtiles/user-guide/reading/#error-handling","title":"Error Handling","text":"<pre><code>try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(zoom, x, y);\n    // Process tile...\n} catch (UncheckedIOException e) {\n    // Handle I/O errors (network issues, file not found, etc.)\n    System.err.println(\"Failed to read PMTiles: \" + e.getMessage());\n} catch (Exception e) {\n    // Handle other errors (invalid format, etc.)\n    System.err.println(\"Error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#next-steps","title":"Next Steps","text":"<ul> <li>Writing PMTiles: Create your own PMTiles archives</li> <li>Cloud Storage: Optimize for cloud storage</li> </ul>"},{"location":"pmtiles/user-guide/writing/","title":"Writing PMTiles","text":"<p>This guide covers creating PMTiles archives.</p> <p>Coming Soon</p> <p>Detailed documentation for PMTiles writing is under development. For now, refer to the JavaDoc API documentation and code examples in the source repository.</p>"},{"location":"pmtiles/user-guide/writing/#basic-writing-example","title":"Basic Writing Example","text":"<pre><code>import io.tileverse.pmtiles.PMTilesWriter;\nimport java.nio.file.Path;\n\n// Create a new PMTiles archive\nPMTilesWriter writer = PMTilesWriter.create(Path.of(\"output.pmtiles\"))\n    .tileType(\"mvt\")  // Vector tiles\n    .minZoom(0)\n    .maxZoom(14)\n    .build();\n\n// Add tiles\nwriter.addTile(10, 885, 412, tileData);\n\n// Close when done\nwriter.close();\n</code></pre>"},{"location":"pmtiles/user-guide/writing/#tile-format","title":"Tile Format","text":"<p>PMTiles supports multiple tile formats:</p> <ul> <li>MVT: Mapbox Vector Tiles (Protocol Buffers)</li> <li>PNG: Raster images with transparency</li> <li>JPEG: Raster images</li> <li>WEBP: Modern image format</li> </ul>"},{"location":"pmtiles/user-guide/writing/#best-practices","title":"Best Practices","text":"<ol> <li>Write tiles in Hilbert order for optimal spatial locality</li> <li>Set appropriate compression for your tile type</li> <li>Include metadata in the header (attribution, description, etc.)</li> <li>Validate tiles before adding to archive</li> </ol>"},{"location":"pmtiles/user-guide/writing/#see-also","title":"See Also","text":"<ul> <li>Reading PMTiles</li> <li>PMTiles Specification</li> </ul>"},{"location":"rangereader/","title":"Range Reader","text":"<p>Range Reader is the foundational I/O layer for the Tileverse ecosystem. It provides a unified API for efficient, random-access byte reading across local files, HTTP endpoints, and cloud storage services.</p>"},{"location":"rangereader/#core-concepts","title":"Core Concepts","text":"<p>The library is built around the <code>RangeReader</code> interface, which abstracts the underlying storage mechanism. This allows upper-level applications (like PMTiles readers) to be agnostic about where the data resides.</p>"},{"location":"rangereader/#supported-backends","title":"Supported Backends","text":"Backend Class Description Local File <code>FileRangeReader</code> Uses <code>java.nio.channels.FileChannel</code> for efficient local reads. HTTP/HTTPS <code>HttpRangeReader</code> Uses <code>java.net.http.HttpClient</code> with <code>Range</code> headers. AWS S3 <code>S3RangeReader</code> Native AWS SDK integration. Azure Blob <code>AzureRangeReader</code> Native Azure SDK integration. Google Cloud <code>GcsRangeReader</code> Native Google Cloud Storage integration."},{"location":"rangereader/#performance-features","title":"Performance Features","text":"<ul> <li>Smart Caching: Decorate any reader with <code>CachingRangeReader</code> to cache frequently accessed headers or index sections in memory or on disk.</li> <li>Block Alignment: Optimize read requests to align with cloud storage pricing models (e.g., reading full 4KB or 16KB blocks to minimize GET requests).</li> <li>Coalescing: Automatically merges adjacent read requests to reduce network overhead.</li> </ul>"},{"location":"rangereader/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/#basic-usage","title":"Basic Usage","text":"<pre><code>// 1. Create a basic reader (e.g., S3)\nvar s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .build();\n\n// 2. Wrap with performance optimizations\nvar reader = CachingRangeReader.builder(s3Reader)\n    .capacity(1024 * 1024 * 10) // 10 MB cache\n    .build();\n\n// 3. Read arbitrary byte ranges\nByteBuffer header = reader.readRange(0, 127);\nheader.flip();\nByteBuffer slice = reader.readRange(5000, 1000); // Read 1000 bytes at offset 5000\nslice.flip();\n</code></pre>"},{"location":"rangereader/developer-guide/","title":"Range Reader Internals","text":"<p>This section covers the internal architecture and performance characteristics specific to the Range Reader library.</p> <p>For general development guidelines (building, testing, contributing), please refer to the main Developer Guide.</p>"},{"location":"rangereader/developer-guide/#contents","title":"Contents","text":"<ul> <li>Architecture: Implementation details, SPI, and Decorator patterns.</li> <li>Performance: Caching strategies, connection pooling, and tuning.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/","title":"Architecture","text":"<p>This document explains the internal design of the Range Reader library, detailing how it achieves a unified API across diverse storage backends.</p> <p></p>"},{"location":"rangereader/developer-guide/architecture/#core-design","title":"Core Design","text":"<p>The library is built around a single, synchronous interface: <code>RangeReader</code>.</p> <pre><code>public interface RangeReader extends Closeable {\n    // The fundamental atomic operation\n    int readRange(long offset, int length, ByteBuffer target) throws IOException;\n\n    // Metadata\n    long size() throws IOException;\n    String getSourceIdentifier();\n}\n</code></pre>"},{"location":"rangereader/developer-guide/architecture/#design-decisions","title":"Design Decisions","text":"<ol> <li>Synchronous API: We chose a blocking API over <code>CompletableFuture</code> or Reactor. This simplifies the implementation of complex logic (like caching and retries) and aligns with Java's <code>FileChannel</code> and standard <code>InputStream</code> patterns, which are what most format parsers expect.</li> <li>ByteBuffers: All data transfer happens via <code>java.nio.ByteBuffer</code>. This allows for off-heap storage, direct memory mapping, and efficient I/O operations without unnecessary array copying.</li> <li>Thread Safety: All implementations must be thread-safe. State (like connection pools) is shared, but individual read operations are isolated.</li> </ol>"},{"location":"rangereader/developer-guide/architecture/#implementation-hierarchy","title":"Implementation Hierarchy","text":""},{"location":"rangereader/developer-guide/architecture/#base-layer-abstractrangereader","title":"Base Layer: <code>AbstractRangeReader</code>","text":"<p>This abstract class handles the boilerplate:</p> <ul> <li>Argument validation (bounds checks).</li> <li>Buffer handling (position management, slicing).</li> <li>Template pattern: delegates the actual byte fetching to <code>readRangeNoFlip</code>.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#backend-layer","title":"Backend Layer","text":"<p>These classes implement the actual network/disk I/O:</p> <ul> <li><code>FileRangeReader</code>: Wraps <code>FileChannel</code>. Uses OS page cache.</li> <li><code>HttpRangeReader</code>: Uses <code>java.net.http.HttpClient</code> to issue <code>GET</code> requests with <code>Range</code> headers.</li> <li><code>S3RangeReader</code>: Wraps AWS SDK v2. Maps exceptions to standard <code>IOException</code>.</li> <li><code>Azure</code> / <code>GCS</code>: Similar wrappers for their respective SDKs.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#decorator-layer","title":"Decorator Layer","text":"<p>We use the Decorator pattern to add behaviors without modifying backends.</p> <ul> <li><code>CachingRangeReader</code>: Intercepts <code>readRange</code>. Checks in-memory Caffeine cache. If miss, calls delegate, caches result, returns data.</li> <li><code>DiskCachingRangeReader</code>: Similar to above, but persists to a local file store.</li> <li><code>BlockAlignedRangeReader</code>: Expands arbitrary read requests (e.g., \"bytes 100-150\") to align with specific block boundaries (e.g., \"bytes 0-4096\"), optimizing cache hit rates.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#runtime-view","title":"Runtime View","text":"<p>The runtime view describes the dynamic behavior of the library.</p>"},{"location":"rangereader/developer-guide/architecture/#basic-file-range-reading","title":"Basic File Range Reading","text":""},{"location":"rangereader/developer-guide/architecture/#http-range-reading-with-authentication","title":"HTTP Range Reading with Authentication","text":""},{"location":"rangereader/developer-guide/architecture/#multi-level-caching-scenario","title":"Multi-Level Caching Scenario","text":""},{"location":"rangereader/developer-guide/architecture/#service-provider-interface-spi","title":"Service Provider Interface (SPI)","text":"<p>To support dynamic loading (e.g., for configuration-driven applications), we expose a <code>RangeReaderFactory</code>.</p> <ol> <li>Discovery: Uses <code>java.util.ServiceLoader</code> to find registered <code>RangeReaderProvider</code> implementations.</li> <li>Resolution: <code>RangeReaderFactory.create(uri)</code> iterates providers. The first one returning <code>true</code> for <code>canHandle(uri)</code> is instantiated.</li> <li>Extensibility: Users can write their own backend (e.g., <code>FtpRangeReader</code>) and register it via <code>META-INF/services</code> without forking the codebase.</li> </ol>"},{"location":"rangereader/developer-guide/architecture/#dependency-structure","title":"Dependency Structure","text":"<p>To avoid \"dependency hell\" (e.g., conflicting Netty versions between Azure and AWS SDKs), the core module has zero heavy dependencies.</p> <ul> <li><code>tileverse-rangereader-core</code>: Lightweight. Only depends on SLF4J and Caffeine.</li> <li><code>tileverse-rangereader-s3</code>: Pulls in AWS SDK.</li> <li><code>tileverse-rangereader-azure</code>: Pulls in Azure SDK.</li> </ul> <p>This allows consumers to pick exactly the providers they need.</p>"},{"location":"rangereader/developer-guide/performance/","title":"Performance Optimization","text":"<p>Understanding how <code>RangeReader</code> behaves under load is critical for high-throughput applications. This guide covers benchmarking and tuning.</p>"},{"location":"rangereader/developer-guide/performance/#benchmarking-methodology","title":"Benchmarking Methodology","text":"<p>We use JMH (Java Microbenchmark Harness) to measure performance. This ensures we avoid JVM warm-up pitfalls and get statistically significant results.</p>"},{"location":"rangereader/developer-guide/performance/#running-benchmarks","title":"Running Benchmarks","text":"<p>The <code>benchmarks</code> module contains pre-configured tests.</p> <pre><code># Build the benchmarks jar\nmvn clean package -pl benchmarks -am\n\n# Run S3 benchmarks\njava -jar benchmarks/target/benchmarks.jar S3RangeReaderBenchmark\n</code></pre>"},{"location":"rangereader/developer-guide/performance/#key-metrics","title":"Key Metrics","text":"<p>We primarily measure:</p> <ol> <li>Throughput (ops/sec): How many ranges can we read per second?</li> <li>Latency (p99): What is the worst-case time for a single read?</li> <li>Allocation Rate: How much garbage are we generating per read?</li> </ol>"},{"location":"rangereader/developer-guide/performance/#tuning-strategies","title":"Tuning Strategies","text":""},{"location":"rangereader/developer-guide/performance/#1-buffer-management","title":"1. Buffer Management","text":"<ul> <li> <p>Problem: Allocating a new <code>byte[]</code> or <code>ByteBuffer</code> for every read puts pressure on the Garbage Collector (GC).</p> </li> <li> <p>Solution: Use the <code>readRange(offset, length, targetBuffer)</code> overload. Reuse a thread-local or pooled <code>ByteBuffer</code>.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#2-connection-pooling","title":"2. Connection Pooling","text":"<ul> <li> <p>Problem: TLS handshakes are expensive. Creating a new S3/HTTP client for every request kills performance.</p> </li> <li> <p>Solution: The library pools connections by default. Ensure you reuse the <code>RangeReader</code> instance. Do not create a new <code>RangeReader</code> for every tile; create it once per file/session.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#3-block-alignment","title":"3. Block Alignment","text":"<ul> <li> <p>Problem: Cloud providers charge per request. Reading 10 bytes here and 10 bytes there generates many requests.</p> </li> <li> <p>Solution: Use <code>BlockAlignedRangeReader</code>. It effectively \"quantizes\" reads.</p> <ul> <li>Scenario: You read byte 10, then byte 20.</li> <li>Without Alignment: 2 network requests.</li> <li>With Alignment (4KB): Request 1 fetches 0-4096. Request 2 is served from cache.</li> </ul> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#4-read-coalescing","title":"4. Read Coalescing","text":"<ul> <li> <p>Concept: If an application requests bytes <code>0-100</code> and <code>100-200</code> in rapid succession (or concurrently), the reader can merge these into a single <code>0-200</code> request.</p> </li> <li> <p>Implementation: Currently handled via the <code>CachingRangeReader</code> and Block Alignment. Future versions may support explicit request coalescing for async patterns.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#cloud-considerations","title":"Cloud Considerations","text":"<ul> <li>AWS S3: The <code>S3RangeReader</code> uses the Apache HTTP client backend instead of Netty to reduce classpath conflicts. We tune the connection pool size to match standard concurrency levels (default 50).</li> <li>Latency: S3 Time-to-First-Byte (TTFB) is typically 50-100ms. Caching is mandatory for interactive performance.</li> </ul>"},{"location":"rangereader/user-guide/","title":"User Guide","text":"<p>Welcome to the Tileverse Range Reader User Guide! This section provides comprehensive guidance for developers who want to integrate the library into their applications.</p>"},{"location":"rangereader/user-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers everything you need to know to effectively use the Tileverse Range Reader library:</p> <ul> <li>Installation: How to add the library to your project</li> <li>Quick Start: Get up and running with basic examples</li> <li>Configuration: Advanced configuration options for optimal performance</li> <li>Authentication: Setting up authentication for cloud providers and HTTP sources</li> <li>Troubleshooting: Common issues and their solutions</li> </ul>"},{"location":"rangereader/user-guide/#real-world-use-cases","title":"Real-World Use Cases","text":"<p>The Tileverse Range Reader library addresses critical needs in modern geospatial and data processing applications:</p>"},{"location":"rangereader/user-guide/#geospatial-data-processing","title":"\ud83c\udf0d Geospatial Data Processing","text":"<ul> <li>Cloud Optimized GeoTIFF (COG) reading for satellite imagery analysis</li> <li>PMTiles serving for high-performance web mapping</li> <li>GeoParquet processing for large-scale vector analytics</li> <li>Zarr access for multi-dimensional geospatial datasets</li> <li>FlatGeobuf streaming for efficient vector data queries</li> </ul>"},{"location":"rangereader/user-guide/#enterprise-applications","title":"\ud83c\udfe2 Enterprise Applications","text":"<ul> <li>Server-side tile rendering without downloading entire datasets</li> <li>Microservices architecture with cloud-native data access</li> <li>Data pipelines that process specific portions of large files</li> <li>Analytics platforms performing random access on cloud-stored data</li> </ul>"},{"location":"rangereader/user-guide/#performance-critical-systems","title":"\ud83d\ude80 Performance-Critical Systems","text":"<ul> <li>Real-time mapping applications requiring sub-second response times</li> <li>Large-scale batch processing with optimized I/O patterns</li> <li>Mobile and embedded systems with bandwidth constraints</li> <li>Multi-tenant platforms with shared caching strategies</li> </ul>"},{"location":"rangereader/user-guide/#target-audience","title":"Target Audience","text":"<p>This guide is designed for:</p> <ul> <li>Java Developers building geospatial or data processing applications</li> <li>Application Architects designing cloud-native data access systems</li> <li>DevOps Engineers deploying and optimizing data-intensive applications</li> <li>Performance Engineers optimizing I/O patterns and caching strategies</li> <li>Library Authors building format readers on a common foundation</li> </ul>"},{"location":"rangereader/user-guide/#getting-started-quickly","title":"Getting Started Quickly","text":"<p>If you're in a hurry, start with these essentials:</p> <ol> <li>Installation - Add the library to your project</li> <li>Quick Start - Basic usage examples</li> <li>Configuration - Performance optimization</li> </ol>"},{"location":"rangereader/user-guide/#library-overview","title":"Library Overview","text":"<p>The Tileverse Range Reader provides a unified interface for reading byte ranges from various sources:</p> <pre><code>// The core interface - same for all data sources\npublic interface RangeReader extends Closeable {\n    ByteBuffer readRange(long offset, int length) throws IOException;\n    int readRange(long offset, int length, ByteBuffer target) throws IOException;\n    long size() throws IOException;\n    String getSourceIdentifier();\n}\n</code></pre>"},{"location":"rangereader/user-guide/#supported-data-sources","title":"Supported Data Sources","text":"Data Source Module Authentication Local Files <code>core</code> File system permissions HTTP/HTTPS <code>core</code> Basic, Bearer, API Key, Digest, Custom Amazon S3 <code>s3</code> AWS credentials, IAM roles Azure Blob Storage <code>azure</code> Connection strings, SAS tokens, Azure AD Google Cloud Storage <code>gcs</code> Service accounts, ADC"},{"location":"rangereader/user-guide/#performance-features","title":"Performance Features","text":"<p>The library includes several performance optimization features:</p> <ul> <li>Memory Caching: Fast access to recently used ranges</li> <li>Disk Caching: Persistent caching for large datasets</li> <li>Block Alignment: Optimized read patterns for cloud storage</li> <li>Concurrent Access: Thread-safe implementations</li> </ul>"},{"location":"rangereader/user-guide/#common-use-cases","title":"Common Use Cases","text":""},{"location":"rangereader/user-guide/#pmtiles-and-tiled-data","title":"PMTiles and Tiled Data","text":"<p>Perfect for accessing tile data without loading entire files:</p> <pre><code>// Read PMTiles header\nByteBuffer header = reader.readRange(0, 127);\nheader.flip();\n\n// Read specific tiles based on tile index\nByteBuffer tileData = reader.readRange(tileOffset, tileLength);\ntileData.flip();\n</code></pre>"},{"location":"rangereader/user-guide/#large-file-processing","title":"Large File Processing","text":"<p>Process large files in chunks:</p> <pre><code>long fileSize = reader.size();\nint chunkSize = 1024 * 1024; // 1MB chunks\n\nfor (long offset = 0; offset &lt; fileSize; offset += chunkSize) {\n    int length = (int) Math.min(chunkSize, fileSize - offset);\n    ByteBuffer chunk = reader.readRange(offset, length);\n    chunk.flip();\n    // Process chunk\n}\n</code></pre>"},{"location":"rangereader/user-guide/#cloud-data-analysis","title":"Cloud Data Analysis","text":"<p>Efficiently access cloud-stored datasets:</p> <pre><code>// Read dataset metadata\nByteBuffer metadata = reader.readRange(0, 1024);\nmetadata.flip();\n\n// Read specific data sections\nByteBuffer section1 = reader.readRange(metadataSize, sectionLength);\nsection1.flip();\nByteBuffer section2 = reader.readRange(section1Offset, section1Length);\nsection2.flip();\n</code></pre>"},{"location":"rangereader/user-guide/#performance-considerations","title":"Performance Considerations","text":""},{"location":"rangereader/user-guide/#decorator-stacking-order","title":"Decorator Stacking Order","text":"<p>For optimal performance, stack decorators in this order:</p> <pre><code>Application\n    \u2193\nCachingRangeReader (memory cache - outermost)\n    \u2193  \nDiskCachingRangeReader (persistent cache)\n    \u2193\nBaseReader (S3, Azure, HTTP, etc.)\n    \u2193\nData Source\n</code></pre>"},{"location":"rangereader/user-guide/#read-pattern-guidelines","title":"Read Pattern Guidelines","text":"Data Source Recommended Strategy Rationale Local Files Direct access OS already provides efficient file caching HTTP Chunked reading (256 KB - 1 MB) Reduce request overhead S3 Large chunks (1 MB - 8 MB) Minimize API calls, optimize for S3's performance characteristics Azure Blob Large chunks (1 MB - 4 MB) Balance throughput and latency Google Cloud Large chunks (1 MB - 8 MB) Optimize for GCS performance"},{"location":"rangereader/user-guide/#memory-management","title":"Memory Management","text":"<p>Configure caching based on your available memory:</p> <pre><code>// For memory-constrained environments\nCachingRangeReader.builder(delegate)\n    .maximumSize(100)  // Limit number of cached ranges\n    .softValues()      // Allow GC to reclaim memory\n    .build()\n\n// For memory-rich environments  \nCachingRangeReader.builder(delegate)\n    .maxSizeBytes(512 * 1024 * 1024)  // 512MB cache\n    .expireAfterAccess(30, TimeUnit.MINUTES)\n    .build()\n</code></pre>"},{"location":"rangereader/user-guide/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p> Installation</p> <p>Add the library to your Maven project</p> <p> Install</p> </li> <li> <p> Quick Start</p> <p>Basic examples for each data source</p> <p> Examples</p> </li> <li> <p> Configuration</p> <p>Optimize performance for your use case</p> <p> Configure</p> </li> <li> <p> Authentication</p> <p>Set up secure access to your data</p> <p> Auth Setup</p> </li> </ul>"},{"location":"rangereader/user-guide/#need-help","title":"Need Help?","text":"<ul> <li>Check the Troubleshooting guide for common issues</li> <li>Review the Quick Start for code examples</li> <li>Read the Configuration guide for advanced setup</li> <li>Visit our GitHub repository for the latest updates</li> </ul>"},{"location":"rangereader/user-guide/authentication/","title":"Authentication Setup","text":"<p>This guide details how to configure credentials for cloud storage and secure HTTP endpoints.</p>"},{"location":"rangereader/user-guide/authentication/#http-sources","title":"HTTP Sources","text":"<p>The <code>HttpRangeReader</code> supports standard authentication schemes via builder methods or property configuration.</p>"},{"location":"rangereader/user-guide/authentication/#basic-auth","title":"Basic Auth","text":"<p>For simple username/password protection.</p> BuilderProperties <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://secure.example.com/data.bin\"))\n    .basicAuth(\"user\", \"pass\")\n    .build();\n</code></pre> <pre><code>var props = new Properties();\nprops.setProperty(\"io.tileverse.rangereader.http.username\", \"user\");\nprops.setProperty(\"io.tileverse.rangereader.http.password\", \"pass\");\n\nvar reader = RangeReaderFactory.create(uri, props);\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#bearer-tokens","title":"Bearer Tokens","text":"<p>Commonly used with OAuth2 and JWT.</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://api.example.com/data\"))\n    .bearerToken(System.getenv(\"API_TOKEN\"))\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#custom-headers-api-keys","title":"Custom Headers / API Keys","text":"<p>For services requiring specific header schemes (e.g., <code>X-API-Key</code>).</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://api.provider.com/data\"))\n    // Arguments: Header Name, Value, Prefix (optional)\n    .apiKey(\"X-Custom-Auth\", \"secret-key-123\", null) \n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#aws-s3","title":"AWS S3","text":"<p>The <code>S3RangeReader</code> integrates with the standard AWS SDK default credential chain.</p>"},{"location":"rangereader/user-guide/authentication/#default-discovery-order","title":"Default Discovery Order","text":"<p>The library attempts to find credentials in the following order (standard AWS behavior):</p> <ol> <li>Environment Variables (<code>AWS_ACCESS_KEY_ID</code>, etc.)</li> <li>System Properties (<code>aws.accessKeyId</code>, etc.)</li> <li>Web Identity Token (for EKS/K8s)</li> <li><code>~/.aws/credentials</code> file</li> <li>EC2 Instance Profile</li> </ol>"},{"location":"rangereader/user-guide/authentication/#explicit-configuration","title":"Explicit Configuration","text":"<p>To force a specific credential provider or profile:</p> <pre><code>// Use a specific profile from ~/.aws/credentials\nvar profileParams = ProfileCredentialsProvider.create(\"production\");\n\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/map.pmtiles\"))\n    .credentialsProvider(profileParams)\n    .region(Region.US_EAST_1)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#assume-role-sts","title":"Assume Role (STS)","text":"<p>To access cross-account resources via STS:</p> <pre><code>var stsClient = StsClient.builder().region(Region.US_EAST_1).build();\n\nvar roleProvider = StsAssumeRoleCredentialsProvider.builder()\n    .stsClient(stsClient)\n    .refreshRequest(req -&gt; req\n        .roleArn(\"arn:aws:iam::123456789012:role/CrossAccountAccess\")\n        .roleSessionName(\"tileverse-session\"))\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://external-bucket/data\"))\n    .credentialsProvider(roleProvider)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#azure-blob-storage","title":"Azure Blob Storage","text":""},{"location":"rangereader/user-guide/authentication/#sas-token-recommended","title":"SAS Token (Recommended)","text":"<p>Shared Access Signatures provide granular control over access.</p> <pre><code>// Token typically generated by a backend service\nvar sasToken = \"sv=2020-08-04&amp;ss=b&amp;srt=o&amp;sp=r&amp;se=2024-01-01...\";\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .sasToken(sasToken)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#connection-string","title":"Connection String","text":"<p>Useful for server-side applications with full access keys.</p> <pre><code>var conn = \"DefaultEndpointsProtocol=https;AccountName=...;AccountKey=...\";\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .connectionString(conn)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#managed-identity","title":"Managed Identity","text":"<p>For applications running within Azure infrastructure (VMs, App Service, AKS).</p> <pre><code>var credential = new DefaultAzureCredentialBuilder().build();\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .credential(credential)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#google-cloud-storage-gcs","title":"Google Cloud Storage (GCS)","text":""},{"location":"rangereader/user-guide/authentication/#application-default-credentials-adc","title":"Application Default Credentials (ADC)","text":"<p>Recommended for most environments. The library automatically looks for:</p> <ol> <li><code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable.</li> <li>Credentials set via <code>gcloud auth application-default login</code>.</li> <li>Attached Service Account (GCE, GKE, Cloud Run).</li> </ol> <pre><code>// No extra config needed if ADC is set up\nvar reader = GoogleCloudStorageRangeReader.builder()\n    .uri(URI.create(\"gs://my-bucket/data\"))\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#service-account-key-json","title":"Service Account Key (JSON)","text":"<p>If you need to manually load a key file:</p> <pre><code>try (var input = new FileInputStream(\"/path/to/key.json\")) {\n    var creds = ServiceAccountCredentials.fromStream(input);\n\n    var reader = GoogleCloudStorageRangeReader.builder()\n        .uri(URI.create(\"gs://my-bucket/data\"))\n        .credentials(creds)\n        .build();\n}\n</code></pre>"},{"location":"rangereader/user-guide/configuration/","title":"Performance Configuration","text":"<p>This guide covers how to tune the <code>RangeReader</code> for different workloads, such as random access (tiles), sequential processing (ETL), or high-latency environments.</p>"},{"location":"rangereader/user-guide/configuration/#caching-layers","title":"Caching Layers","text":"<p>Caching is critical when reading from remote sources (S3, HTTP) to minimize latency and cost.</p>"},{"location":"rangereader/user-guide/configuration/#memory-cache-cachingrangereader","title":"Memory Cache (<code>CachingRangeReader</code>)","text":"<p>Best for: Random access, Tile servers, Metadata headers.</p> <pre><code>var s3Reader = S3RangeReader.builder().uri(uri).build();\n\nvar cachedReader = CachingRangeReader.builder(s3Reader)\n    // Strategy 1: Max entries (good for header/directory blocks)\n    .maximumSize(1000)\n\n    // Strategy 2: Max memory (e.g., 128MB)\n    .maxSizeBytes(128L * 1024 * 1024)\n\n    // Strategy 3: Expiration\n    .expireAfterAccess(10, TimeUnit.MINUTES)\n\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#disk-cache-diskcachingrangereader","title":"Disk Cache (<code>DiskCachingRangeReader</code>)","text":"<p>Best for: Large datasets, Repeated runs, Offline capability.</p> <pre><code>var diskCachedReader = DiskCachingRangeReader.builder(s3Reader)\n    .cacheDirectory(Path.of(\"/mnt/fast-ssd/cache\"))\n    // Hard limit on disk usage (e.g., 10GB)\n    .maxCacheSizeBytes(10L * 1024 * 1024 * 1024)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#read-optimization","title":"Read Optimization","text":""},{"location":"rangereader/user-guide/configuration/#block-alignment","title":"Block Alignment","text":"<p>Cloud storage APIs (S3, GCS) often perform better (and cost less) when reading aligned blocks rather than many tiny, fragmented ranges.</p> <pre><code>// Align reads to 64KB boundaries\nvar alignedReader = BlockAlignedRangeReader.builder(reader)\n    .blockSize(64 * 1024) \n    .build();\n</code></pre> <p>Impact: If you request bytes <code>100-200</code>, the reader fetches <code>0-65536</code>. If you essentially request <code>200-300</code>, it's served from memory/disk cache immediately.</p>"},{"location":"rangereader/user-guide/configuration/#provider-specific-tuning","title":"Provider-Specific Tuning","text":""},{"location":"rangereader/user-guide/configuration/#amazon-s3","title":"Amazon S3","text":"<p>Using the native AWS SDK client allows for deep configuration:</p> <pre><code>var s3Client = S3Client.builder()\n    .region(Region.US_WEST_2)\n    .httpClient(ApacheHttpClient.builder()\n        .maxConnections(50)\n        .socketTimeout(Duration.ofSeconds(10))\n        .build())\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .client(s3Client)\n    .bucket(\"maps\")\n    .key(\"planet.pmtiles\")\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#http-https","title":"HTTP / HTTPS","text":"<p>You can tune the underlying HTTP connection pool and timeouts:</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .connectTimeout(Duration.ofSeconds(5))\n    .readTimeout(Duration.ofSeconds(30))\n    // Enable GZIP if the server supports range requests with compression\n    .compressionEnabled(true) \n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#global-properties","title":"Global Properties","text":"<p>For environments where code changes are difficult, you can configure defaults via system properties:</p> Property Description Default <code>io.tileverse.rangereader.http.timeout-millis</code> Global HTTP timeout 5000 <code>io.tileverse.rangereader.http.trust-all-certificates</code> Disable SSL verification (Dev only) false"},{"location":"rangereader/user-guide/configuration/#stack-recommendations","title":"Stack Recommendations","text":""},{"location":"rangereader/user-guide/configuration/#for-tile-servers","title":"For Tile Servers","text":"<p>A tile server needs low latency. Stack memory caching on top of disk caching.</p> <pre><code>// 1. Base S3 Reader\nvar base = S3RangeReader.builder().uri(uri).build();\n\n// 2. Disk Cache (Persistent L2)\nvar l2 = DiskCachingRangeReader.builder(base)\n    .cacheDirectory(cacheDir)\n    .maxCacheSizeBytes(50_000_000_000L) // 50GB\n    .build();\n\n// 3. Memory Cache (Fast L1)\nvar reader = CachingRangeReader.builder(l2)\n    .maximumSize(10_000) // Keep hot tiles in RAM\n    .softValues()        // Let JVM reclaim memory if needed\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#for-data-pipelines-etl","title":"For Data Pipelines (ETL)","text":"<p>ETL jobs often read large chunks sequentially. Memory caching is less useful; focusing on throughput is key.</p> <pre><code>var reader = DiskCachingRangeReader.builder(base)\n    .maxCacheSizeBytes(1_000_000_000L) // 1GB buffer\n    .deleteOnClose()                   // Clean up after job\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/installation/","title":"Installation","text":"<p>This guide explains how to add the Tileverse Range Reader library to your Java project.</p>"},{"location":"rangereader/user-guide/installation/#maven-installation","title":"Maven Installation","text":""},{"location":"rangereader/user-guide/installation/#using-the-bom-recommended","title":"Using the BOM (Recommended)","text":"<p>The project provides a Bill of Materials (BOM) to manage dependency versions:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n    &lt;!-- Now you can omit versions - they're managed by the BOM --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Add cloud provider modules as needed --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#all-modules-simple-approach","title":"All Modules (Simple Approach)","text":"<p>Include all functionality with a single dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>No More Netty Conflicts</p> <p>A major benefit of this library is that the <code>s3</code> and <code>azure</code> modules can be used together without causing <code>netty</code> dependency conflicts.</p> <p>Historically, using the AWS and Azure Java SDKs in the same project was challenging because they relied on incompatible versions of Netty. This library solves that problem by using alternative HTTP clients (Apache HttpClient for S3, <code>java.net.HttpClient</code> for Azure), removing Netty entirely. You can now build multi-cloud applications without complex dependency management.</p>"},{"location":"rangereader/user-guide/installation/#individual-modules-without-bom","title":"Individual Modules (Without BOM)","text":"<p>If you prefer not to use the BOM, specify versions explicitly:</p>"},{"location":"rangereader/user-guide/installation/#core-module-required","title":"Core Module (Required)","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-core&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#cloud-provider-modules","title":"Cloud Provider Modules","text":"Amazon S3Azure Blob StorageGoogle Cloud Storage <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-azure&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-gcs&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#dependency-management-boms","title":"Dependency Management BOMs","text":"<p>The project provides two BOMs for different use cases:</p>"},{"location":"rangereader/user-guide/installation/#tileverse-bom","title":"Tileverse BOM","text":"<p>Manages versions of all Tileverse Range Reader modules:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#dependencies-bom","title":"Dependencies BOM","text":"<p>Manages versions of third-party dependencies (for library developers):</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre> <p>This BOM includes managed versions for:</p> <ul> <li>AWS SDK components</li> <li>Azure Storage SDK components  </li> <li>Google Cloud Storage SDK components</li> <li>Jackson (JSON processing)</li> <li>Caffeine (caching)</li> </ul>"},{"location":"rangereader/user-guide/installation/#gradle-installation","title":"Gradle Installation","text":""},{"location":"rangereader/user-guide/installation/#using-the-bom-recommended_1","title":"Using the BOM (Recommended)","text":"<pre><code>dependencyManagement {\n    imports {\n        mavenBom 'io.tileverse:tileverse-bom:1.0-SNAPSHOT'\n    }\n}\n\ndependencies {\n    // Versions managed by the BOM\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-core'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-s3'\n}\n</code></pre>"},{"location":"rangereader/user-guide/installation/#all-modules","title":"All Modules","text":"<pre><code>implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.0-SNAPSHOT'\n</code></pre>"},{"location":"rangereader/user-guide/installation/#individual-modules","title":"Individual Modules","text":"<pre><code>// Core module (required)\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-core:1.0-SNAPSHOT'\n\n// Cloud provider modules (optional)\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-s3:1.0-SNAPSHOT'\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-azure:1.0-SNAPSHOT'\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-gcs:1.0-SNAPSHOT'\n</code></pre>"},{"location":"rangereader/user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test to verify the installation:</p> <pre><code>import io.tileverse.rangereader.FileRangeReader;\nimport java.nio.file.Path;\nimport java.nio.file.Files;\n\npublic class InstallationTest {\n    public static void main(String[] args) throws Exception {\n        // Create a temporary test file\n        Path testFile = Files.createTempFile(\"test\", \".bin\");\n        Files.write(testFile, \"Hello, World!\".getBytes());\n\n        // Test the library\n        try (var reader = FileRangeReader.builder()\n                .path(testFile)\n                .build()) {\n\n            var data = reader.readRange(0, 5);\n            data.flip();\n            String result = new String(data.array(), 0, data.remaining());\n            System.out.println(\"Read: \" + result); // Should print \"Hello\"\n\n            System.out.println(\"Installation successful!\");\n        }\n\n        // Clean up\n        Files.deleteIfExists(testFile);\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/installation/#migration-guide","title":"Migration Guide","text":""},{"location":"rangereader/user-guide/installation/#from-other-range-reading-libraries","title":"From Other Range Reading Libraries","text":"<p>Common migration patterns:</p> <ul> <li>Map offset/length operations to <code>readRange()</code> calls</li> <li>Replace custom caching with built-in decorators  </li> <li>Adopt builder patterns for configuration instead of constructors</li> </ul>"},{"location":"rangereader/user-guide/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Basic usage examples</li> <li>Configuration: Performance optimization</li> <li>Authentication: Cloud provider setup</li> </ul>"},{"location":"rangereader/user-guide/quick-start/","title":"Quick Start","text":"<p>Get started with the Tileverse Range Reader library in minutes with these basic examples.</p>"},{"location":"rangereader/user-guide/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"rangereader/user-guide/quick-start/#reading-from-local-files","title":"Reading from Local Files","text":"<pre><code>import io.tileverse.rangereader.FileRangeReader;\nimport java.nio.ByteBuffer;\nimport java.nio.file.Path;\n\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"data.bin\"))\n        .build()) {\n\n    // Read first 1024 bytes\n    ByteBuffer header = reader.readRange(0, 1024);\n    header.flip(); // Prepare buffer for reading\n\n    // Read a specific section\n    ByteBuffer chunk = reader.readRange(50000, 8192);\n    chunk.flip(); // Prepare buffer for reading\n\n    // Get total file size\n    long size = reader.size();\n\n    System.out.println(\"File size: \" + size + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#reading-from-http","title":"Reading from HTTP","text":"<pre><code>import io.tileverse.rangereader.HttpRangeReader;\nimport java.net.URI;\n\ntry (var reader = HttpRangeReader.builder()\n        .uri(URI.create(\"https://example.com/data.bin\"))\n        .build()) {\n\n    // Read range from remote file\n    ByteBuffer data = reader.readRange(1000, 500);\n    data.flip(); // Prepare buffer for reading\n\n    System.out.println(\"Read \" + data.remaining() + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#reading-from-amazon-s3","title":"Reading from Amazon S3","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\nimport java.net.URI;\n\ntry (var reader = S3RangeReader.builder()\n        .uri(URI.create(\"s3://my-bucket/data.bin\"))\n        .region(Region.US_WEST_2)\n        .build()) {\n\n    // Read from S3 object\n    ByteBuffer data = reader.readRange(0, 1024);\n    data.flip();\n\n    System.out.println(\"Read from S3: \" + data.remaining() + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#performance-optimization","title":"Performance Optimization","text":""},{"location":"rangereader/user-guide/quick-start/#adding-memory-caching","title":"Adding Memory Caching","text":"<p>Memory caching is most beneficial for cloud storage where network latency is significant:</p> <pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\n// Use caching with cloud storage for maximum benefit\nvar baseReader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/large-file.bin\"))\n    .region(Region.US_WEST_2)\n    .build();\n\ntry (var cachedReader = CachingRangeReader.builder(baseReader)\n        .maximumSize(1000)  // Cache up to 1000 ranges\n        .build()) {\n\n    // First read - network request to S3\n    ByteBuffer data1 = cachedReader.readRange(0, 1024);\n    data1.flip();\n\n    // Second read - served from cache (much faster, no network)\n    ByteBuffer data2 = cachedReader.readRange(0, 1024);\n    data2.flip();\n}\n</code></pre> <p>Note: For local files, caching provides little benefit since the OS already caches file data efficiently.</p>"},{"location":"rangereader/user-guide/quick-start/#disk-caching-for-large-datasets","title":"Disk Caching for Large Datasets","text":"<pre><code>import io.tileverse.rangereader.cache.DiskCachingRangeReader;\n\nvar s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/large-file.bin\"))\n    .build();\n\ntry (var cachedReader = DiskCachingRangeReader.builder(s3Reader)\n        .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB cache\n        .build()) {\n\n    // Reads are cached to disk for persistence across sessions\n    ByteBuffer data = cachedReader.readRange(100, 500);\n    data.flip();\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>// Optimal configuration for cloud storage\ntry (var optimizedReader = CachingRangeReader.builder(\n        DiskCachingRangeReader.builder(\n            S3RangeReader.builder()\n                .uri(URI.create(\"s3://bucket/data.bin\"))\n                .build())\n            .maxCacheSizeBytes(10L * 1024 * 1024 * 1024)  // 10GB disk cache\n            .build())\n        .maximumSize(1000)  // 1000 entries in memory\n        .build()) {\n\n    // Highly optimized reads with multiple caching layers\n    ByteBuffer data = optimizedReader.readRange(offset, length);\n    data.flip(); // Prepare buffer for reading\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#working-with-bytebuffers","title":"Working with ByteBuffers","text":""},{"location":"rangereader/user-guide/quick-start/#reusing-buffers-recommended","title":"Reusing Buffers (Recommended)","text":"<pre><code>// Efficient: Reuse the same buffer\nByteBuffer buffer = ByteBuffer.allocate(8192);\n\nfor (long offset = 0; offset &lt; fileSize; offset += 8192) {\n    buffer.clear();  // Reset for writing\n\n    int bytesRead = reader.readRange(offset, 8192, buffer);\n    buffer.flip(); // Prepare buffer for reading\n\n    // Process buffer contents\n    processData(buffer);\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#direct-buffers-for-large-reads","title":"Direct Buffers for Large Reads","text":"<pre><code>// For large reads, use direct buffers\nByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);\n\ntry {\n    int bytesRead = reader.readRange(0, 1024 * 1024, directBuffer);\n    directBuffer.flip();\n\n    // Process large chunk efficiently\n    processLargeData(directBuffer);\n} finally {\n    // Clean up direct buffer if needed\n    if (directBuffer.isDirect()) {\n        ((DirectBuffer) directBuffer).cleaner().clean();\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>import java.io.IOException;\n\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"data.bin\"))\n        .build()) {\n\n    // Validate before reading\n    long fileSize = reader.size();\n    long offset = 1000;\n    int length = 500;\n\n    if (offset &gt;= fileSize) {\n        System.out.println(\"Offset beyond file end\");\n        return;\n    }\n\n    // Adjust length if it extends beyond EOF\n    if (offset + length &gt; fileSize) {\n        length = (int) (fileSize - offset);\n    }\n\n    ByteBuffer data = reader.readRange(offset, length);\n    data.flip(); // Prepare buffer for reading\n\n} catch (IOException e) {\n    System.err.println(\"Failed to read data: \" + e.getMessage());\n} catch (IllegalArgumentException e) {\n    System.err.println(\"Invalid parameters: \" + e.getMessage());\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"rangereader/user-guide/quick-start/#reading-file-headers","title":"Reading File Headers","text":"<pre><code>// Read different header formats\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"image.tiff\"))\n        .build()) {\n\n    // Read TIFF header\n    ByteBuffer header = reader.readRange(0, 16);\n    header.flip(); // Prepare buffer for reading\n\n    // Check magic number\n    short magic = header.getShort();\n\n    if (magic == 0x4949 || magic == 0x4D4D) {\n        System.out.println(\"Valid TIFF file\");\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#streaming-large-files","title":"Streaming Large Files","text":"<pre><code>// Process large files in chunks\npublic void processLargeFile(Path filePath, int chunkSize) throws IOException {\n    try (var reader = FileRangeReader.builder()\n            .path(filePath)\n            .build()) {\n\n        long fileSize = reader.size();\n        long processed = 0;\n\n        while (processed &lt; fileSize) {\n            int currentChunkSize = (int) Math.min(chunkSize, fileSize - processed);\n\n            ByteBuffer chunk = reader.readRange(processed, currentChunkSize);\n            chunk.flip(); // Prepare buffer for reading\n\n            // Process this chunk\n            processChunk(chunk);\n\n            processed += currentChunkSize;\n\n            // Report progress\n            double progress = (double) processed / fileSize * 100;\n            System.out.printf(\"Progress: %.1f%%\\n\", progress);\n        }\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration: Learn about performance tuning</li> <li>Authentication: Set up cloud provider access</li> <li>Troubleshooting: Common issues and solutions</li> </ul>"},{"location":"rangereader/user-guide/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions when using the Tileverse Range Reader library.</p>"},{"location":"rangereader/user-guide/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>Problem: Maven/Gradle dependency conflicts with AWS, Azure, or Google Cloud SDKs.</p> <p>Solution: Use the BOM (Bill of Materials) for version alignment:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- AWS BOM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n            &lt;artifactId&gt;bom&lt;/artifactId&gt;\n            &lt;version&gt;2.31.70&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Azure BOM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.azure&lt;/groupId&gt;\n            &lt;artifactId&gt;azure-sdk-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.2.28&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#java-version-issues","title":"Java Version Issues","text":"<p>Problem: <code>UnsupportedClassVersionError</code> or similar Java version errors.</p> <p>Solution: Ensure you're using Java 17 or higher:</p> <pre><code>java -version\n# Should show version 17 or higher\n\n# Set JAVA_HOME if needed\nexport JAVA_HOME=/path/to/java17\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#missing-module-errors","title":"Missing Module Errors","text":"<p>Problem: <code>ClassNotFoundException</code> for cloud provider classes.</p> <p>Solution: Include the specific module dependency:</p> <pre><code>&lt;!-- For S3 support --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#aws-s3-authentication","title":"AWS S3 Authentication","text":"<p>Problem: <code>SdkClientException: Unable to load AWS credentials</code></p> <p>Solutions:</p> <ol> <li> <p>Set environment variables:    <pre><code>export AWS_ACCESS_KEY_ID=your-access-key\nexport AWS_SECRET_ACCESS_KEY=your-secret-key\nexport AWS_DEFAULT_REGION=us-west-2\n</code></pre></p> </li> <li> <p>Create AWS credentials file:    <pre><code>mkdir -p ~/.aws\ncat &gt; ~/.aws/credentials &lt;&lt; EOF\n[default]\naws_access_key_id = your-access-key\naws_secret_access_key = your-secret-key\nEOF\n</code></pre></p> </li> <li> <p>Use IAM role (on EC2/ECS):    <pre><code>// No explicit credentials needed - uses instance profile\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .region(Region.US_WEST_2)\n    .build();\n</code></pre></p> </li> </ol> <p>Problem: <code>S3Exception: Access Denied (Service: S3, Status Code: 403)</code></p> <p>Solutions:</p> <ol> <li> <p>Check bucket permissions:    <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\"s3:GetObject\"],\n      \"Resource\": \"arn:aws:s3:::your-bucket/*\"\n    }\n  ]\n}\n</code></pre></p> </li> <li> <p>Verify object exists:    <pre><code>aws s3 ls s3://your-bucket/your-key\n</code></pre></p> </li> <li> <p>Check region:    <pre><code>// Ensure region matches bucket region\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .region(Region.US_WEST_2)  // Correct region\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#azure-blob-storage-authentication","title":"Azure Blob Storage Authentication","text":"<p>Problem: <code>BlobStorageException: AuthenticationFailed</code></p> <p>Solutions:</p> <ol> <li> <p>Verify connection string:    <pre><code>var connectionString = \"DefaultEndpointsProtocol=https;\" +\n    \"AccountName=youraccount;\" +\n    \"AccountKey=yourkey;\" +\n    \"EndpointSuffix=core.windows.net\";\n</code></pre></p> </li> <li> <p>Check SAS token expiration:    <pre><code># Decode SAS token to check expiry\necho \"sv=2020-08-04&amp;se=2024-12-31...\" | base64 -d\n</code></pre></p> </li> <li> <p>Test connectivity:    <pre><code>az storage blob list --account-name youraccount --container-name yourcontainer\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#google-cloud-storage-authentication","title":"Google Cloud Storage Authentication","text":"<p>Problem: <code>GoogleCloudStorageException: 403 Forbidden</code></p> <p>Solutions:</p> <ol> <li> <p>Set service account key:    <pre><code>export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json\n</code></pre></p> </li> <li> <p>Test authentication:    <pre><code>gcloud auth application-default login\ngsutil ls gs://your-bucket/\n</code></pre></p> </li> <li> <p>Check service account permissions:    <pre><code>gcloud projects get-iam-policy your-project-id\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#slow-read-performance","title":"Slow Read Performance","text":"<p>Problem: Range reads are slower than expected.</p> <p>Solutions:</p> <ol> <li> <p>Enable caching:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(1000)\n    .build();\n</code></pre></p> </li> <li> <p>Use disk caching for persistent storage:    <pre><code>// For large datasets, use disk caching\nvar reader = DiskCachingRangeReader.builder(cloudReader)\n    .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB cache\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Problem: Application uses too much memory.</p> <p>Solutions:</p> <ol> <li> <p>Use soft references in cache:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .softValues()  // Allow GC to reclaim memory\n    .build();\n</code></pre></p> </li> <li> <p>Limit cache size:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(100)  // Limit entries\n    .maxSizeBytes(64 * 1024 * 1024)  // 64MB limit\n    .build();\n</code></pre></p> </li> <li> <p>Use disk caching instead:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB on disk\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#cache-not-working","title":"Cache Not Working","text":"<p>Problem: Cache statistics show low hit rates.</p> <p>Solutions:</p> <ol> <li> <p>Check cache configuration:    <pre><code>if (reader instanceof CachingRangeReader cachingReader) {\n    var stats = cachingReader.getCacheStats();\n    System.out.println(\"Hit rate: \" + stats.hitRate());\n    System.out.println(\"Miss count: \" + stats.missCount());\n}\n</code></pre></p> </li> <li> <p>Ensure consistent read patterns:    <pre><code>// Good: Consistent block-aligned reads\nfor (int i = 0; i &lt; 10; i++) {\n    reader.readRange(i * 1024, 1024);  // Cache-friendly\n}\n\n// Bad: Random, unaligned reads\nreader.readRange(100, 500);   // Won't benefit from caching\nreader.readRange(1500, 300);\n</code></pre></p> </li> <li> <p>Use appropriate read patterns:    <pre><code>// Ensure consistent read patterns to improve cache hits\nvar reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(1000)\n    .build();\n\n// Read in consistent chunks\nint chunkSize = 64 * 1024;  // 64KB chunks\nfor (int i = 0; i &lt; 10; i++) {\n    reader.readRange(i * chunkSize, chunkSize);  // Cache-friendly\n}\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#network-issues","title":"Network Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#connection-timeouts","title":"Connection Timeouts","text":"<p>Problem: <code>SocketTimeoutException</code> or connection timeouts.</p> <p>Solutions:</p> <ol> <li> <p>Increase timeouts:    <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .connectTimeout(Duration.ofSeconds(30))\n    .readTimeout(Duration.ofMinutes(5))\n    .build();\n</code></pre></p> </li> <li> <p>Configure retries:    <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .maxRetries(3)\n    .retryDelay(Duration.ofSeconds(1))\n    .build();\n</code></pre></p> </li> <li> <p>For S3, configure client:    <pre><code>var s3Client = S3Client.builder()\n    .overrideConfiguration(ClientOverrideConfiguration.builder()\n        .apiCallTimeout(Duration.ofMinutes(2))\n        .apiCallAttemptTimeout(Duration.ofSeconds(30))\n        .build())\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .client(s3Client)\n    .bucket(\"bucket\")\n    .key(\"key\")\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#proxy-configuration","title":"Proxy Configuration","text":"<p>Problem: Cannot connect through corporate proxy.</p> <p>Solutions:</p> <ol> <li> <p>Set system properties:    <pre><code>-Dhttp.proxyHost=proxy.company.com\n-Dhttp.proxyPort=8080\n-Dhttps.proxyHost=proxy.company.com\n-Dhttps.proxyPort=8080\n</code></pre></p> </li> <li> <p>Configure AWS SDK proxy:    <pre><code>var proxyConfig = ProxyConfiguration.builder()\n    .endpoint(URI.create(\"http://proxy.company.com:8080\"))\n    .username(\"proxyuser\")\n    .password(\"proxypass\")\n    .build();\n\nvar s3Client = S3Client.builder()\n    .overrideConfiguration(ClientOverrideConfiguration.builder()\n        .proxyConfiguration(proxyConfig)\n        .build())\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":"<p>Problem: SSL certificate validation errors.</p> <p>Solutions:</p> <ol> <li> <p>For development only - disable SSL verification:    <pre><code>// NOT recommended for production\nvar reader = HttpRangeReader.builder()\n    .uri(uri)\n    .trustAllCertificates(true)\n    .build();\n</code></pre></p> </li> <li> <p>Add custom certificate to truststore:    <pre><code>keytool -import -alias custom-cert -file cert.crt -keystore $JAVA_HOME/lib/security/cacerts\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#file-system-issues","title":"File System Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#file-access-permissions","title":"File Access Permissions","text":"<p>Problem: <code>AccessDeniedException</code> when reading local files.</p> <p>Solutions:</p> <ol> <li> <p>Check file permissions:    <pre><code>ls -la /path/to/file\nchmod 644 /path/to/file  # Make readable\n</code></pre></p> </li> <li> <p>Verify file exists:    <pre><code>Path filePath = Path.of(\"/path/to/file\");\nif (!Files.exists(filePath)) {\n    throw new FileNotFoundException(\"File not found: \" + filePath);\n}\nif (!Files.isReadable(filePath)) {\n    throw new IOException(\"File not readable: \" + filePath);\n}\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#disk-cache-issues","title":"Disk Cache Issues","text":"<p>Problem: Disk cache not working or filling up disk.</p> <p>Solutions:</p> <ol> <li> <p>Check disk space:    <pre><code>df -h /tmp/rangereader-cache\n</code></pre></p> </li> <li> <p>Configure cache location:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .cacheDirectory(\"/var/cache/rangereader\")  // Custom location\n    .maxCacheSizeBytes(5L * 1024 * 1024 * 1024)  // 5GB limit\n    .build();\n</code></pre></p> </li> <li> <p>Enable cleanup on close:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .deleteOnClose()  // Clean up when done\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"rangereader/user-guide/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>// Add to your application startup\nSystem.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", \"DEBUG\");\nSystem.setProperty(\"org.slf4j.simpleLogger.log.io.tileverse.rangereader\", \"DEBUG\");\n\n// For AWS SDK\nSystem.setProperty(\"org.slf4j.simpleLogger.log.software.amazon.awssdk\", \"DEBUG\");\n\n// For Azure SDK\nSystem.setProperty(\"org.slf4j.simpleLogger.log.com.azure\", \"DEBUG\");\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#monitor-cache-performance","title":"Monitor Cache Performance","text":"<pre><code>public void monitorCache(RangeReader reader) {\n    if (reader instanceof CachingRangeReader cachingReader) {\n        var stats = cachingReader.getCacheStats();\n\n        System.out.println(\"Cache Statistics:\");\n        System.out.println(\"  Hit Rate: \" + String.format(\"%.2f%%\", stats.hitRate() * 100));\n        System.out.println(\"  Requests: \" + stats.requestCount());\n        System.out.println(\"  Hits: \" + stats.hitCount());\n        System.out.println(\"  Misses: \" + stats.missCount());\n        System.out.println(\"  Evictions: \" + stats.evictionCount());\n        System.out.println(\"  Size: \" + stats.estimatedSize());\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#test-connectivity","title":"Test Connectivity","text":"<pre><code>public void testConnectivity(URI uri) {\n    try {\n        var reader = createReader(uri);\n        long size = reader.size();\n        System.out.println(\"Successfully connected to \" + uri + \", size: \" + size);\n        reader.close();\n    } catch (Exception e) {\n        System.err.println(\"Failed to connect to \" + uri + \": \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#profile-performance","title":"Profile Performance","text":"<pre><code>public void profileReads(RangeReader reader) {\n    int numReads = 100;\n    int blockSize = 64 * 1024;\n\n    long startTime = System.nanoTime();\n\n    for (int i = 0; i &lt; numReads; i++) {\n        try {\n            reader.readRange(i * blockSize, blockSize);\n        } catch (IOException e) {\n            System.err.println(\"Read failed at offset \" + (i * blockSize));\n        }\n    }\n\n    long endTime = System.nanoTime();\n    double durationMs = (endTime - startTime) / 1_000_000.0;\n\n    System.out.println(\"Read \" + numReads + \" blocks in \" + durationMs + \"ms\");\n    System.out.println(\"Average: \" + (durationMs / numReads) + \"ms per read\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check the logs for detailed error messages</li> <li>Search GitHub issues for similar problems</li> <li>Create a minimal reproduction case</li> <li>Submit an issue with:</li> <li>Library version</li> <li>Java version</li> <li>Operating system</li> <li>Complete error message and stack trace</li> <li>Minimal code example</li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Likely Cause Solution <code>ClassNotFoundException</code> Missing module dependency Add required module to dependencies <code>Access Denied (403)</code> Authentication/authorization Check credentials and permissions <code>NoSuchFileException</code> File not found Verify file/object exists <code>SocketTimeoutException</code> Network timeout Increase timeout or check connectivity <code>OutOfMemoryError</code> Large cache or buffer usage Reduce cache size or use disk caching <code>UnsupportedClassVersionError</code> Wrong Java version Use Java 17 or higher"},{"location":"tilematrixset/","title":"Tile Matrix Set","text":"<p>A Java implementation of the OGC Two-Phase Tile Matrix Set (TMS) standard. This library handles the mathematical complexity of tile pyramids, coordinate systems, and grid definitions.</p>"},{"location":"tilematrixset/#features","title":"Features","text":"<ul> <li>OGC Compliance: Implements the data model for Tile Matrix Sets.</li> <li>Standard Sets: Includes built-in definitions for <code>WebMercatorQuad</code> and <code>WorldCRS84Quad</code>.</li> <li>Math Utilities: Helper functions for converting between bounding boxes, geographic coordinates, and tile indices.</li> </ul>"},{"location":"tilematrixset/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.tilematrixset&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-tilematrixset&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tilematrixset/#usage","title":"Usage","text":""},{"location":"tilematrixset/#working-with-coordinates","title":"Working with Coordinates","text":"<pre><code>import io.tileverse.tiling.matrix.DefaultTileMatrixSets;\n\nvar tms = DefaultTileMatrixSets.WEB_MERCATOR_QUAD;\nvar matrix = tms.tileMatrix(12); // Zoom level 12\n\n// Calculate which tiles cover a specific geographic area\nvar bbox = new BoundingBox2D(-74.0, 40.7, -73.9, 40.8); // NYC\nvar tileRange = matrix.getTilesIntersecting(bbox);\n\nSystem.out.println(\"Tiles needed: \" + tileRange.size());\nfor (var tile : tileRange) {\n    System.out.printf(\"Fetch z=%d x=%d y=%d%n\", 12, tile.x(), tile.y());\n}\n</code></pre>"},{"location":"tilematrixset/user-guide/","title":"Tile Matrix Set User Guide","text":"<p>Learn how to work with tile pyramids and matrix sets.</p>"},{"location":"tilematrixset/user-guide/#installation","title":"Installation","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.tilematrixset&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-tilematrixset&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.tileverse.tilematrixset:tileverse-tilematrixset:1.1-SNAPSHOT'\n</code></pre>"},{"location":"tilematrixset/user-guide/#topics","title":"Topics","text":"<ul> <li>Quick Start</li> <li>Tile Pyramids</li> <li>Standard Sets</li> </ul>"},{"location":"tilematrixset/user-guide/quick-start/","title":"Quick Start","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"tilematrixset/user-guide/standard-sets/","title":"Standard Sets","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"tilematrixset/user-guide/tile-pyramids/","title":"Tile Pyramids","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"vectortiles/","title":"Vector Tiles","text":"<p>A high-performance library for encoding and decoding Mapbox Vector Tiles (MVT) in Java. It bridges the gap between raw Protocol Buffers data and usable Java objects (JTS Geometries).</p>"},{"location":"vectortiles/#capabilities","title":"Capabilities","text":"<ul> <li>MVT v2.1 Compliance: Full support for layers, features, and values.</li> <li>JTS Integration: Direct conversion between MVT geometry commands and JTS <code>Geometry</code> objects.</li> <li>Zero-Copy Decoding: Optimized parsing strategies to minimize object allocation during reads.</li> </ul>"},{"location":"vectortiles/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.vectortiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-vectortiles&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"vectortiles/#usage","title":"Usage","text":""},{"location":"vectortiles/#decoding","title":"Decoding","text":"<p>Convert raw MVT bytes (e.g., from a PMTiles archive or network request) into a structured Java object.</p> <pre><code>import io.tileverse.vectortile.mvt.VectorTileCodec;\n\nbyte[] rawBytes = ...; // your MVT data\n\nvar codec = VectorTileCodec.getDefault();\nvar tile = codec.decode(rawBytes);\n\nfor (var layer : tile.getLayers()) {\n    System.out.println(\"Layer: \" + layer.getName());\n\n    for (var feature : layer.getFeatures()) {\n        // Access JTS Geometry directly\n        org.locationtech.jts.geom.Geometry geom = feature.getGeometry();\n        Map&lt;String, Object&gt; props = feature.getAttributes();\n    }\n}\n</code></pre>"},{"location":"vectortiles/#encoding","title":"Encoding","text":"<p>Create MVTs from scratch using JTS geometries.</p> <pre><code>import io.tileverse.vectortile.mvt.VectorTileBuilder;\n\nvar builder = VectorTileBuilder.create();\nvar layer = builder.layer(\"buildings\");\n\nlayer.feature()\n     .id(123)\n     .geometry(jtsPolygon)\n     .attribute(\"height\", 50)\n     .attribute(\"type\", \"residential\");\n\nbyte[] encoded = codec.encode(builder.build());\n</code></pre>"},{"location":"vectortiles/user-guide/","title":"Vector Tiles User Guide","text":"<p>Welcome to the Tileverse Vector Tiles User Guide.</p>"},{"location":"vectortiles/user-guide/#overview","title":"Overview","text":"<p>This guide covers encoding and decoding Mapbox Vector Tiles (MVT) in Java.</p>"},{"location":"vectortiles/user-guide/#installation","title":"Installation","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.vectortiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-vectortiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.tileverse.vectortiles:tileverse-vectortiles:1.1-SNAPSHOT'\n</code></pre>"},{"location":"vectortiles/user-guide/#topics","title":"Topics","text":"<ul> <li>Quick Start: Get started quickly</li> <li>Encoding Tiles: Create MVT tiles</li> <li>Decoding Tiles: Read MVT tiles</li> </ul>"},{"location":"vectortiles/user-guide/#next-steps","title":"Next Steps","text":"<p>Start with the Quick Start guide.</p>"},{"location":"vectortiles/user-guide/decoding/","title":"Decoding Vector Tiles","text":"<p>Coming Soon</p> <p>Detailed decoding documentation is under development.</p> <p>See Quick Start for basic examples.</p>"},{"location":"vectortiles/user-guide/encoding/","title":"Encoding Vector Tiles","text":"<p>Coming Soon</p> <p>Detailed encoding documentation is under development.</p> <p>See Quick Start for basic examples.</p>"},{"location":"vectortiles/user-guide/quick-start/","title":"Vector Tiles Quick Start","text":"<p>Get started with Tileverse Vector Tiles quickly.</p>"},{"location":"vectortiles/user-guide/quick-start/#decoding-mvt","title":"Decoding MVT","text":"<pre><code>import io.tileverse.vectortile.mvt.VectorTileCodec;\nimport io.tileverse.vectortile.model.VectorTile;\n\nVectorTileCodec codec = VectorTileCodec.getDefault();\nbyte[] mvtBytes = ...; // Load from file, network, etc.\n\nVectorTile tile = codec.decode(mvtBytes);\n\n// Iterate layers and features\nfor (VectorTile.Layer layer : tile.getLayers()) {\n    System.out.println(\"Layer: \" + layer.getName());\n    for (VectorTile.Layer.Feature feature : layer.getFeatures()) {\n        System.out.println(\"  Feature ID: \" + feature.getId());\n        System.out.println(\"  Geometry: \" + feature.getGeometry());\n        System.out.println(\"  Attributes: \" + feature.getAttributes());\n    }\n}\n</code></pre>"},{"location":"vectortiles/user-guide/quick-start/#encoding-mvt","title":"Encoding MVT","text":"<pre><code>import io.tileverse.vectortile.mvt.VectorTileBuilder;\n\nVectorTileBuilder builder = VectorTileBuilder.create();\n\nbuilder.layer(\"poi\")\n    .feature()\n        .geometry(point)\n        .attributes(Map.of(\"name\", \"Restaurant\"));\n\nVectorTile tile = builder.build();\nbyte[] mvtBytes = codec.encode(tile);\n</code></pre>"},{"location":"vectortiles/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Encoding Tiles</li> <li>Decoding Tiles</li> </ul>"}]}