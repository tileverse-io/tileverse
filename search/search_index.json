{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tileverse","text":"<p>Tileverse provides a toolkit of independent Java libraries for building cloud-native geospatial applications. </p> <p>These libraries are designed to be composable: pick the ones you need for your specific problem\u2014whether that's reading from cloud storage, handling vector tiles, or calculating tile grids\u2014without pulling in a monolithic framework.</p>"},{"location":"#libraries","title":"Libraries","text":"Library Artifact Role Range Reader <code>tileverse-rangereader-all</code> I/O Abstraction: Unified API for efficient byte-range access across S3, Azure, GCS, HTTP, and local files. PMTiles <code>tileverse-pmtiles</code> Archive Format: Read/write support for PMTiles v3, leveraging Range Reader for cloud access. Vector Tiles <code>tileverse-vectortiles</code> Codec: High-performance encoding and decoding of Mapbox Vector Tiles (MVT) to/from JTS Geometries. Tile Matrix Set <code>tileverse-tilematrixset</code> Math &amp; Logic: Implementation of the OGC Tile Matrix Set standard for calculating tile pyramids and grids."},{"location":"#ecosystem","title":"Ecosystem","text":"<p>While <code>tileverse-pmtiles</code> naturally uses the other libraries, Range Reader, Vector Tiles, and Tile Matrix Set are completely standalone. </p> <ul> <li>Building a tile server from PostGIS? Use Vector Tiles and Tile Matrix Set.</li> <li>Reading COGs (Cloud Optimized GeoTIFFs)? Use Range Reader.</li> <li>Need a standard grid definition? Use Tile Matrix Set.</li> </ul> <pre><code>graph TD\n    App[Your App]\n\n    subgraph \"I/O\"\n        RR[Range Reader]\n    end\n\n    subgraph \"Formats\"\n        VT[Vector Tiles]\n        PMT[PMTiles]\n    end\n\n    subgraph \"Spatial\"\n        TMS[Tile Matrix Set]\n    end\n\n    App --&gt; RR\n    App --&gt; VT\n    App --&gt; PMT\n    App --&gt; TMS\n\n    PMT -.-&gt; RR\n    PMT -.-&gt; VT\n    PMT -.-&gt; TMS</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Tileverse is available on Maven Central. You can use the Bill of Materials (BOM) to manage versions across all modules.</p> MavenGradle <p>Add the BOM to your <code>dependencyManagement</code> to ensure version consistency:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0.0&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre> <p>Then add specific modules to your <code>dependencies</code> block:</p> <pre><code>&lt;dependencies&gt;\n    &lt;!-- Efficient data access (File, HTTP, S3, etc.) --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- PMTiles support --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>dependencies {\n    implementation(platform(\"io.tileverse:tileverse-bom:1.0.0\"))\n\n    implementation(\"io.tileverse.rangereader:tileverse-rangereader-all\")\n    implementation(\"io.tileverse.pmtiles:tileverse-pmtiles\")\n}\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#reading-a-pmtiles-archive","title":"Reading a PMTiles Archive","text":"<p>This example demonstrates how to read a PMTiles file from a local path using the <code>FileRangeReader</code>.</p> <pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\npublic class Example {\n    public void readTile() throws Exception {\n        // Initialize the underlying data source\n        var source = FileRangeReader.builder()\n            .path(Path.of(\"data/planet.pmtiles\"))\n            .build();\n\n        // Open the PMTiles reader\n        try (var reader = new PMTilesReader(source::asByteChannel)) {\n            // Fetch a specific tile (z=0, x=0, y=0)\n            Optional&lt;ByteBuffer&gt; tile = reader.getTile(0, 0, 0);\n\n            tile.ifPresent(buffer -&gt; {\n                buffer.flip(); // Important: flip the buffer before reading\n                System.out.println(\"Found tile: \" + buffer.remaining() + \" bytes\");\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#cloud-storage-access","title":"Cloud Storage Access","text":"<p>To access files on S3, swap the <code>FileRangeReader</code> for <code>S3RangeReader</code>. The upper-level <code>PMTilesReader</code> API remains unchanged.</p> <pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\nimport java.net.URI;\n\nvar s3Source = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/maps/planet.pmtiles\"))\n    .region(Region.US_EAST_1)\n    .build();\n\n// Wrap with caching for performance\nvar cachedSource = CachingRangeReader.builder(s3Source)\n    .capacity(50_000_000) // 50MB cache\n    .build();\n\nvar reader = new PMTilesReader(cachedSource::asByteChannel);\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Java 17 or later.</li> <li>Maven 3.8+ or Gradle 7+.</li> </ul>"},{"location":"architecture/","title":"System Architecture","text":"<p>Tileverse is designed as a collection of loosely coupled, composable libraries. While they work seamlessly together, each module acts as a standalone tool for its specific domain (I/O, Tiling, Encodings).</p>"},{"location":"architecture/#component-relationships","title":"Component Relationships","text":"<p>The following diagram illustrates how the libraries relate to user applications and each other. Note that <code>pmtiles</code> is the only module that strictly depends on others (<code>rangereader</code> for I/O and <code>vectortiles</code> for decoding).</p> <pre><code>graph TD\n    subgraph \"Application Layer\"\n        App[User Application]\n    end\n\n    subgraph \"Independent Modules\"\n        RR[tileverse-rangereader]\n        VT[tileverse-vectortiles]\n        TMS[tileverse-tilematrixset]\n    end\n\n    subgraph \"Composed Modules\"\n        PMT[tileverse-pmtiles]\n    end\n\n    App --&gt; RR\n    App --&gt; VT\n    App --&gt; TMS\n    App --&gt; PMT\n\n    PMT --&gt; RR\n    PMT --&gt; VT\n    PMT --&gt; TMS</code></pre>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":""},{"location":"architecture/#1-io-independence-rangereader","title":"1. I/O Independence (<code>rangereader</code>)","text":"<p>We treat data access as a distinct problem from data format. </p> <ul> <li>Goal: Read bytes from anywhere (S3, HTTP, Azure, File) efficiently.</li> <li>Anti-Pattern: Format libraries (like a GeoTIFF reader) implementing their own S3 clients.</li> <li>Solution: <code>RangeReader</code> provides a unified <code>readRange(start, length)</code> interface.</li> </ul>"},{"location":"architecture/#2-pure-mathematical-models-tilematrixset","title":"2. Pure Mathematical Models (<code>tilematrixset</code>)","text":"<p>Spatial reference systems and grid logic are kept separate from data storage.</p> <ul> <li>Goal: Calculate tile coordinates and bounding boxes without external dependencies.</li> <li>Benefit: Can be used by a tile server to calculate grids even if the data source isn't Java-based or uses a different I/O library.</li> </ul>"},{"location":"architecture/#3-format-specificity-vectortiles-pmtiles","title":"3. Format Specificity (<code>vectortiles</code>, <code>pmtiles</code>)","text":"<p>These libraries handle the parsing and encoding logic for specific file specs.</p> <ul> <li>Vector Tiles: Pure Protocol Buffers / JTS transcoding. No I/O logic.</li> <li>PMTiles: Orchestrates <code>RangeReader</code> to fetch specific directory bytes, uses <code>VectorTiles</code> to parse the result, and <code>TileMatrixSet</code> to understand the grid.</li> </ul>"},{"location":"architecture/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/#direct-usage","title":"Direct Usage","text":"<p>Applications often use modules directly:</p> <ul> <li>ETL Pipelines: Use <code>vectortiles</code> to convert PostGIS geometry to MVT bytes.</li> <li>Tile Servers: Use <code>tilematrixset</code> to calculate which tiles cover a viewport.</li> <li>Data Access: Use <code>rangereader</code> to fetch partial content from Cloud Optimized GeoTIFFs (COGs) stored on S3.</li> </ul>"},{"location":"architecture/#composed-usage","title":"Composed Usage","text":"<p>The <code>pmtiles</code> library demonstrates the power of composition:</p> <ol> <li>Accepts a <code>RangeReader</code> interface (polymorphic backend).</li> <li>Uses <code>HilbertCurve</code> (internal) for index lookup.</li> <li>Returns raw bytes or uses <code>vectortiles</code> to return parsed geometry.</li> </ol>"},{"location":"architecture/dependencies/","title":"Module Dependencies","text":"<p>Tileverse aims to minimize transitive dependencies while leveraging established libraries for core functionality.</p>"},{"location":"architecture/dependencies/#core-dependencies","title":"Core Dependencies","text":"Library Usage Module JTS Topology Suite Geometry model (Points, Polygons, etc.) <code>vectortiles</code>, <code>pmtiles</code> Caffeine High-performance in-memory caching <code>rangereader</code> Jackson JSON parsing (metadata, configurations) <code>pmtiles</code> Google Protocol Buffers MVT binary encoding/decoding <code>vectortiles</code> SLF4J Logging abstraction All"},{"location":"architecture/dependencies/#optional-dependencies","title":"Optional Dependencies","text":"<p>These are only required if you use specific features (e.g., cloud storage).</p> Library Usage Module AWS SDK for Java v2 S3 Range Reader <code>rangereader-s3</code> Azure SDK for Java Azure Blob Range Reader <code>rangereader-azure</code> Google Cloud Java GCS Range Reader <code>rangereader-gcs</code> Apache Commons Compress Zstd compression support <code>pmtiles</code>"},{"location":"architecture/system-design/","title":"System Design","text":""},{"location":"architecture/system-design/#data-flow-architecture","title":"Data Flow Architecture","text":"<p>Tileverse allows applications to stream tiled data from remote storage directly to the client (or processing engine) with minimal memory overhead.</p>"},{"location":"architecture/system-design/#1-request-lifecycle","title":"1. Request Lifecycle","text":"<p>When a <code>PMTilesReader</code> requests a tile <code>(z, x, y)</code>:</p> <ol> <li>Spatial Index Lookup: The reader calculates the Hilbert ID for the requested tile.</li> <li>Directory Fetch: It checks if the relevant directory section is in memory. If not, it issues a byte-range request to the <code>RangeReader</code>.</li> <li>Offset Calculation: Using the directory data, it finds the exact byte offset and length of the tile data in the archive.</li> <li>Data Fetch: It issues a second byte-range request to the <code>RangeReader</code> for the actual tile body.</li> <li>Decoding: The raw bytes are passed to the <code>VectorTileCodec</code> (if MVT) or returned as-is (if Raster).</li> </ol>"},{"location":"architecture/system-design/#2-caching-strategy","title":"2. Caching Strategy","text":"<p>To avoid network latency, the <code>CachingRangeReader</code> implements a two-tier cache:</p> <ul> <li>Tier 1 (Metadata): PMTiles directories and headers are highly cacheable and small. They are prioritized in the \"Meta\" cache.</li> <li>Tier 2 (Data): Actual tile data is cached in a separate \"Data\" cache (optional), useful for hot areas of the map.</li> </ul>"},{"location":"architecture/system-design/#3-extensibility","title":"3. Extensibility","text":"<p>The system is designed for extension via interfaces:</p> <ul> <li>Implement <code>RangeReader</code> to support a new storage backend (e.g., Hadoop HDFS, FTP).</li> <li>Implement <code>TileMatrixSet</code> to support exotic non-Earth coordinate systems.</li> </ul>"},{"location":"pmtiles/","title":"PMTiles","text":"<p>This module provides a pure Java implementation of the PMTiles v3 specification, a single-file archive format for cloud-optimized tiled data.</p>"},{"location":"pmtiles/#features","title":"Features","text":"<ul> <li>Read &amp; Write: Full support for creating and consuming PMTiles archives.</li> <li>Storage Agnostic: Works seamlessly with any Range Reader backend (S3, HTTP, Local File).</li> <li>Spatial Indexing: Implements Hilbert curve indexing for O(log N) tile lookups.</li> <li>Type Support: Handles both vector (MVT) and raster (PNG, JPG, WebP) tiles.</li> </ul>"},{"location":"pmtiles/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pmtiles/#usage","title":"Usage","text":""},{"location":"pmtiles/#reading","title":"Reading","text":"<p>The <code>PMTilesReader</code> accepts a <code>Supplier&lt;SeekableByteChannel&gt;</code>. The <code>RangeReader</code> can provide this via its <code>asByteChannel()</code> method.</p> <pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\n\nvar source = FileRangeReader.builder()\n    .path(Path.of(\"data/map.pmtiles\"))\n    .build();\n\ntry (var reader = new PMTilesReader(source::asByteChannel)) {\n    // Get metadata\n    var header = reader.getHeader();\n    System.out.println(\"Min Zoom: \" + header.minZoom());\n\n    // Fetch tile (z, x, y)\n    reader.getTile(0, 0, 0).ifPresent(buffer -&gt; {\n        buffer.flip(); // Important: flip the buffer before reading\n        // Process tile bytes...\n    });\n}\n</code></pre>"},{"location":"pmtiles/#writing","title":"Writing","text":"<p>Writing involves the <code>PMTilesWriter</code> which organizes input data into the proper directory structure with Hilbert ordering.</p> <pre><code>var writer = new PMTilesWriter(outputStream);\n\n// Add tiles (order doesn't matter, writer handles sorting)\nwriter.addTile(0, 0, 0, tileBytes);\n\n// Finalize and write directory\nwriter.finish();\n</code></pre>"},{"location":"pmtiles/user-guide/","title":"PMTiles User Guide","text":"<p>Welcome to the Tileverse PMTiles User Guide. This guide will help you understand and use the PMTiles library effectively.</p>"},{"location":"pmtiles/user-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers:</p> <ul> <li>Quick Start: Get up and running quickly</li> <li>Reading PMTiles: Read tiles from PMTiles archives</li> <li>Writing PMTiles: Create new PMTiles archives</li> <li>Cloud Storage: Work with PMTiles in S3, Azure, and GCS</li> </ul>"},{"location":"pmtiles/user-guide/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Java 17 or newer installed</li> <li>Basic familiarity with Maven or Gradle</li> <li>Understanding of tile-based mapping concepts</li> </ul>"},{"location":"pmtiles/user-guide/#installation","title":"Installation","text":"<p>Add the PMTiles dependency to your project:</p> MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Also add a Range Reader provider --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies {\n    implementation 'io.tileverse.pmtiles:tileverse-pmtiles:1.1-SNAPSHOT'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.1-SNAPSHOT'\n}\n</code></pre>"},{"location":"pmtiles/user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"pmtiles/user-guide/#pmtiles-structure","title":"PMTiles Structure","text":"<p>A PMTiles archive contains:</p> <ol> <li>Header: Metadata about the tileset (bounds, zoom levels, tile format)</li> <li>Directory: Spatial index using Hilbert curves</li> <li>Tiles: Compressed tile data</li> </ol>"},{"location":"pmtiles/user-guide/#tile-addressing","title":"Tile Addressing","text":"<p>Tiles are addressed using the standard XYZ scheme:</p> <ul> <li>z: Zoom level (0 = world view, higher = more detailed)</li> <li>x: Column number (west to east)</li> <li>y: Row number (north to south in TMS, south to north in XYZ)</li> </ul>"},{"location":"pmtiles/user-guide/#data-sources","title":"Data Sources","text":"<p>PMTiles can be read from any source supported by Range Reader:</p> <ul> <li>Local files</li> <li>HTTP/HTTPS servers</li> <li>Amazon S3</li> <li>Azure Blob Storage</li> <li>Google Cloud Storage</li> </ul>"},{"location":"pmtiles/user-guide/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Begin with a simple example</li> <li>Reading PMTiles: Learn about reading tiles</li> <li>Cloud Storage: Access PMTiles from the cloud</li> </ul>"},{"location":"pmtiles/user-guide/cloud-storage/","title":"Cloud Storage Integration","text":"<p>Learn how to efficiently access PMTiles from cloud storage providers.</p>"},{"location":"pmtiles/user-guide/cloud-storage/#overview","title":"Overview","text":"<p>PMTiles is designed to work efficiently with cloud object storage. By using HTTP range requests, you can serve tiles directly from S3, Azure Blob Storage, or Google Cloud Storage without a specialized tile server.</p>"},{"location":"pmtiles/user-guide/cloud-storage/#amazon-s3","title":"Amazon S3","text":""},{"location":"pmtiles/user-guide/cloud-storage/#basic-s3-access","title":"Basic S3 Access","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\n\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/world.pmtiles\"))\n    .region(Region.US_WEST_2)\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(s3Reader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#with-caching","title":"With Caching","text":"<pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\nRangeReader cachedReader = CachingRangeReader.builder(s3Reader)\n    .maximumSize(1000)\n    .withBlockAlignment()\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(cachedReader::asByteChannel)) {\n    // Cached reads\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#azure-blob-storage","title":"Azure Blob Storage","text":"<pre><code>import io.tileverse.rangereader.azure.AzureBlobRangeReader;\n\nRangeReader azureReader = AzureBlobRangeReader.builder()\n    .connectionString(connectionString)\n    .containerName(\"tiles\")\n    .blobPath(\"world.pmtiles\")\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(azureReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#google-cloud-storage","title":"Google Cloud Storage","text":"<pre><code>import io.tileverse.rangereader.gcs.GoogleCloudStorageRangeReader;\n\nRangeReader gcsReader = GoogleCloudStorageRangeReader.builder()\n    .uri(URI.create(\"gs://my-bucket/world.pmtiles\"))\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(gcsReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"pmtiles/user-guide/cloud-storage/#multi-level-caching","title":"Multi-Level Caching","text":"<p>Combine memory and disk caching for optimal performance:</p> <pre><code>// Disk cache\nRangeReader diskCached = DiskCachingRangeReader.builder(s3Reader)\n    .cacheDirectory(Path.of(\"/tmp/tile-cache\"))\n    .maximumCacheSize(10_000_000_000L)  // 10 GB\n    .build();\n\n// Memory cache on top\nRangeReader memoryCached = CachingRangeReader.builder(diskCached)\n    .maximumSize(1000)\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(memoryCached::asByteChannel)) {\n    // Optimized access\n}\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#block-alignment","title":"Block Alignment","text":"<p>Use block-aligned reads to minimize cloud storage requests:</p> <pre><code>RangeReader alignedReader = BlockAlignedRangeReader.builder(s3Reader)\n    .blockSize(65536)  // 64 KB blocks\n    .build();\n</code></pre>"},{"location":"pmtiles/user-guide/cloud-storage/#cost-optimization","title":"Cost Optimization","text":"<ol> <li>Enable caching to reduce request counts</li> <li>Use CDN in front of object storage</li> <li>Choose appropriate storage class (Standard vs. Infrequent Access)</li> <li>Monitor request patterns and adjust caching strategy</li> </ol>"},{"location":"pmtiles/user-guide/cloud-storage/#see-also","title":"See Also","text":"<ul> <li>Range Reader Authentication</li> <li>Range Reader Performance</li> </ul>"},{"location":"pmtiles/user-guide/quick-start/","title":"PMTiles Quick Start","text":"<p>Get started with Tileverse PMTiles in under 5 minutes.</p>"},{"location":"pmtiles/user-guide/quick-start/#installation","title":"Installation","text":"<p>First, add the dependencies:</p> MavenGradle <pre><code>&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.pmtiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-pmtiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>dependencies {\n    implementation 'io.tileverse.pmtiles:tileverse-pmtiles:1.1-SNAPSHOT'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.1-SNAPSHOT'\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-tiles-from-a-local-file","title":"Reading Tiles from a Local File","text":"<pre><code>import io.tileverse.pmtiles.PMTilesReader;\nimport io.tileverse.pmtiles.PMTilesHeader;\nimport io.tileverse.rangereader.RangeReader;\nimport io.tileverse.rangereader.file.FileRangeReader;\nimport java.nio.file.Path;\nimport java.util.Optional;\n\npublic class QuickStart {\n    public static void main(String[] args) throws Exception {\n        // Create a range reader for the PMTiles file\n        RangeReader rangeReader = FileRangeReader.builder()\n            .path(Path.of(\"world.pmtiles\"))\n            .build();\n\n        // Open the PMTiles archive\n        try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n            // Read the header to get metadata\n            PMTilesHeader header = reader.getHeader();\n            System.out.println(\"Tile Format: \" + header.tileType());\n            System.out.println(\"Min Zoom: \" + header.minZoom());\n            System.out.println(\"Max Zoom: \" + header.maxZoom());\n\n            // Get a specific tile (zoom=10, x=885, y=412)\n            Optional&lt;ByteBuffer&gt; tileData = reader.getTile(10, 885, 412);\n\n            if (tileData.isPresent()) {\n                System.out.printf(\"Tile found! Size: %d bytes%n\",\n                    tileData.get().remaining());\n            } else {\n                System.out.println(\"Tile not found\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-from-http","title":"Reading from HTTP","text":"<pre><code>import io.tileverse.rangereader.http.HttpRangeReader;\n\n// Create HTTP range reader\nRangeReader httpReader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://example.com/tiles.pmtiles\"))\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(httpReader::asByteChannel)) {\n    Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);\n    // Process tile...\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#reading-from-s3","title":"Reading from S3","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\n\n// Create S3 range reader\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/world.pmtiles\"))\n    .region(Region.US_WEST_2)\n    .build();\n\n    try (PMTilesReader reader = new PMTilesReader(s3Reader::asByteChannel)) {\n        Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);    // Process tile...\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#with-caching","title":"With Caching","text":"<p>For better performance, especially with cloud storage, add caching:</p> <pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\n// Wrap the base reader with caching\nRangeReader cachedReader = CachingRangeReader.builder(s3Reader)\n    .maximumSize(1000)  // Cache up to 1000 ranges\n    .withBlockAlignment()  // Optimize reads\n    .build();\n\ntry (PMTilesReader reader = new PMTilesReader(cachedReader::asByteChannel)) {\n    // Subsequent reads will be cached\n    Optional&lt;ByteBuffer&gt; tile = reader.getTile(10, 885, 412);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#processing-multiple-tiles","title":"Processing Multiple Tiles","text":"<pre><code>// Get tiles for a specific area\nint zoom = 10;\nint minX = 880, maxX = 890;\nint minY = 410, maxY = 420;\n\ntry (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    for (int x = minX; x &lt;= maxX; x++) {\n        for (int y = minY; y &lt;= maxY; y++) {\n            Optional&lt;ByteBuffer&gt; tile = reader.getTile(zoom, x, y);\n            if (tile.isPresent()) {\n                System.out.printf(\"Tile %d/%d/%d: %d bytes%n\",\n                    zoom, x, y, tile.get().remaining());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Reading PMTiles: Learn more about reading operations</li> <li>Writing PMTiles: Create your own PMTiles archives</li> <li>Cloud Storage: Deep dive into cloud storage integration</li> <li>Range Reader Guide: Understand the underlying data access layer</li> </ul>"},{"location":"pmtiles/user-guide/reading/","title":"Reading PMTiles","text":"<p>This guide covers advanced topics for reading PMTiles archives.</p>"},{"location":"pmtiles/user-guide/reading/#opening-pmtiles-archives","title":"Opening PMTiles Archives","text":"<p>PMTiles archives can be opened from any data source supported by Range Reader:</p> <pre><code>// Local file\nRangeReader fileReader = FileRangeReader.builder()\n    .path(Path.of(\"tiles.pmtiles\"))\n    .build();\n\n// HTTP\nRangeReader httpReader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://example.com/tiles.pmtiles\"))\n    .build();\n\n// S3\nRangeReader s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/tiles.pmtiles\"))\n    .build();\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#reading-header-information","title":"Reading Header Information","text":"<p>The header contains essential metadata about the tileset:</p> <pre><code>try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    PMTilesHeader header = reader.getHeader();\n\n    // Tile format (MVT, PNG, JPEG, WEBP, etc.)\n    String tileType = header.tileType();\n\n    // Zoom level range\n    int minZoom = header.minZoom();\n    int maxZoom = header.maxZoom();\n\n    // Geographic bounds (in E7 format: degrees * 10,000,000)\n    double minLon = header.minLonE7() / 10_000_000.0;\n    double minLat = header.minLatE7() / 10_000_000.0;\n    double maxLon = header.maxLonE7() / 10_000_000.0;\n    double maxLat = header.maxLatE7() / 10_000_000.0;\n\n    System.out.printf(\"Bounds: [%.6f, %.6f, %.6f, %.6f]%n\",\n        minLon, minLat, maxLon, maxLat);\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#reading-individual-tiles","title":"Reading Individual Tiles","text":"<p>Tiles are retrieved using the standard Z/X/Y addressing:</p> <pre><code>Optional&lt;ByteBuffer&gt; tileData = reader.getTile(zoom, x, y);\n\nif (tileData.isPresent()) {\n    ByteBuffer tile = tileData.get();\n    tile.flip(); // Important: flip the buffer before reading\n    // Process tile data...\n} else {\n    // Tile doesn't exist in the archive\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#bulk-tile-operations","title":"Bulk Tile Operations","text":""},{"location":"pmtiles/user-guide/reading/#reading-a-tile-range","title":"Reading a Tile Range","text":"<pre><code>int zoom = 10;\nfor (int x = 880; x &lt;= 890; x++) {\n    for (int y = 410; y &lt;= 420; y++) {\n                    Optional&lt;ByteBuffer&gt; tile = reader.getTile(zoom, x, y);\n                    if (tile.isPresent()) {\n                        tile.get().flip(); // Flip before processing\n                        processTile(zoom, x, y, tile.get());        }\n    }\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#parallel-processing","title":"Parallel Processing","text":"<p>PMTilesReader is thread-safe for read operations:</p> <pre><code>IntStream.range(880, 891)\n    .parallel()\n    .forEach(x -&gt; {\n        IntStream.range(410, 421).forEach(y -&gt; {\n            reader.getTile(zoom, x, y).ifPresent(buffer -&gt; {\n                buffer.flip();\n                processTile(zoom, x, y, buffer);\n            });\n        });\n    });\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use caching for cloud storage sources</li> <li>Enable block alignment for optimal read patterns</li> <li>Reuse readers instead of creating new instances</li> <li>Batch operations when processing multiple tiles</li> </ol> <p>See Cloud Storage for detailed performance optimization strategies.</p>"},{"location":"pmtiles/user-guide/reading/#error-handling","title":"Error Handling","text":"<pre><code>try (PMTilesReader reader = new PMTilesReader(rangeReader::asByteChannel)) {\n    Optional&lt;byte[]&gt; tile = reader.getTile(zoom, x, y);\n    // Process tile...\n} catch (UncheckedIOException e) {\n    // Handle I/O errors (network issues, file not found, etc.)\n    System.err.println(\"Failed to read PMTiles: \" + e.getMessage());\n} catch (Exception e) {\n    // Handle other errors (invalid format, etc.)\n    System.err.println(\"Error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"pmtiles/user-guide/reading/#next-steps","title":"Next Steps","text":"<ul> <li>Writing PMTiles: Create your own PMTiles archives</li> <li>Cloud Storage: Optimize for cloud storage</li> </ul>"},{"location":"pmtiles/user-guide/writing/","title":"Writing PMTiles","text":"<p>This guide covers creating PMTiles archives.</p> <p>Coming Soon</p> <p>Detailed documentation for PMTiles writing is under development. For now, refer to the JavaDoc API documentation and code examples in the source repository.</p>"},{"location":"pmtiles/user-guide/writing/#basic-writing-example","title":"Basic Writing Example","text":"<pre><code>import io.tileverse.pmtiles.PMTilesWriter;\nimport java.nio.file.Path;\n\n// Create a new PMTiles archive\nPMTilesWriter writer = PMTilesWriter.create(Path.of(\"output.pmtiles\"))\n    .tileType(\"mvt\")  // Vector tiles\n    .minZoom(0)\n    .maxZoom(14)\n    .build();\n\n// Add tiles\nwriter.addTile(10, 885, 412, tileData);\n\n// Close when done\nwriter.close();\n</code></pre>"},{"location":"pmtiles/user-guide/writing/#tile-format","title":"Tile Format","text":"<p>PMTiles supports multiple tile formats:</p> <ul> <li>MVT: Mapbox Vector Tiles (Protocol Buffers)</li> <li>PNG: Raster images with transparency</li> <li>JPEG: Raster images</li> <li>WEBP: Modern image format</li> </ul>"},{"location":"pmtiles/user-guide/writing/#best-practices","title":"Best Practices","text":"<ol> <li>Write tiles in Hilbert order for optimal spatial locality</li> <li>Set appropriate compression for your tile type</li> <li>Include metadata in the header (attribution, description, etc.)</li> <li>Validate tiles before adding to archive</li> </ol>"},{"location":"pmtiles/user-guide/writing/#see-also","title":"See Also","text":"<ul> <li>Reading PMTiles</li> <li>PMTiles Specification</li> </ul>"},{"location":"rangereader/","title":"Range Reader","text":"<p>Range Reader is the foundational I/O layer for the Tileverse ecosystem. It provides a unified API for efficient, random-access byte reading across local files, HTTP endpoints, and cloud storage services.</p>"},{"location":"rangereader/#core-concepts","title":"Core Concepts","text":"<p>The library is built around the <code>RangeReader</code> interface, which abstracts the underlying storage mechanism. This allows upper-level applications (like PMTiles readers) to be agnostic about where the data resides.</p>"},{"location":"rangereader/#supported-backends","title":"Supported Backends","text":"Backend Class Description Local File <code>FileRangeReader</code> Uses <code>java.nio.channels.FileChannel</code> for efficient local reads. HTTP/HTTPS <code>HttpRangeReader</code> Uses <code>java.net.http.HttpClient</code> with <code>Range</code> headers. AWS S3 <code>S3RangeReader</code> Native AWS SDK integration. Azure Blob <code>AzureRangeReader</code> Native Azure SDK integration. Google Cloud <code>GcsRangeReader</code> Native Google Cloud Storage integration."},{"location":"rangereader/#performance-features","title":"Performance Features","text":"<ul> <li>Smart Caching: Decorate any reader with <code>CachingRangeReader</code> to cache frequently accessed headers or index sections in memory or on disk.</li> <li>Block Alignment: Optimize read requests to align with cloud storage pricing models (e.g., reading full 4KB or 16KB blocks to minimize GET requests).</li> <li>Coalescing: Automatically merges adjacent read requests to reduce network overhead.</li> </ul>"},{"location":"rangereader/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/#basic-usage","title":"Basic Usage","text":"<pre><code>// 1. Create a basic reader (e.g., S3)\nvar s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .build();\n\n// 2. Wrap with performance optimizations\nvar reader = CachingRangeReader.builder(s3Reader)\n    .capacity(1024 * 1024 * 10) // 10 MB cache\n    .build();\n\n// 3. Read arbitrary byte ranges\nByteBuffer header = reader.readRange(0, 127);\nheader.flip();\nByteBuffer slice = reader.readRange(5000, 1000); // Read 1000 bytes at offset 5000\nslice.flip();\n</code></pre>"},{"location":"rangereader/developer-guide/","title":"Developer Guide","text":"<p>Welcome to the Developer Guide for the Tileverse Range Reader. This guide is for developers who want to contribute to the project, understand its internal architecture, or extend its functionality.</p>"},{"location":"rangereader/developer-guide/#what-youll-find","title":"What You'll Find","text":"<p>This guide provides comprehensive information for project contributors and maintainers:</p> <ul> <li>Architecture: A deep dive into the design patterns, module structure, and core principles of the library.</li> <li>Building: Instructions on how to build the project from source, including prerequisites and build commands.</li> <li>Testing: An overview of the testing strategy, including unit, integration, and performance tests.</li> <li>Performance: Guidance on benchmarking, profiling, and optimizing the library.</li> <li>Contributing: Guidelines for contributing code, documentation, and bug reports.</li> </ul>"},{"location":"rangereader/developer-guide/#prerequisites","title":"Prerequisites","text":"<p>Before you start, ensure you have the following installed:</p> <ul> <li>Java 21+ (for development)</li> <li>Maven 3.9+</li> <li>Docker (for integration tests)</li> <li>Git</li> </ul>"},{"location":"rangereader/developer-guide/architecture/","title":"Architecture","text":"<p>This document explains the internal design of the Range Reader library, detailing how it achieves a unified API across diverse storage backends.</p>"},{"location":"rangereader/developer-guide/architecture/#core-design","title":"Core Design","text":"<p>The library is built around a single, synchronous interface: <code>RangeReader</code>.</p> <pre><code>public interface RangeReader extends Closeable {\n    // The fundamental atomic operation\n    int readRange(long offset, int length, ByteBuffer target) throws IOException;\n\n    // Metadata\n    long size() throws IOException;\n    String getSourceIdentifier();\n}\n</code></pre>"},{"location":"rangereader/developer-guide/architecture/#design-decisions","title":"Design Decisions","text":"<ol> <li>Synchronous API: We chose a blocking API over <code>CompletableFuture</code> or Reactor. This simplifies the implementation of complex logic (like caching and retries) and aligns with Java's <code>FileChannel</code> and standard <code>InputStream</code> patterns, which are what most format parsers expect.</li> <li>ByteBuffers: All data transfer happens via <code>java.nio.ByteBuffer</code>. This allows for off-heap storage, direct memory mapping, and efficient I/O operations without unnecessary array copying.</li> <li>Thread Safety: All implementations must be thread-safe. State (like connection pools) is shared, but individual read operations are isolated.</li> </ol>"},{"location":"rangereader/developer-guide/architecture/#implementation-hierarchy","title":"Implementation Hierarchy","text":""},{"location":"rangereader/developer-guide/architecture/#base-layer-abstractrangereader","title":"Base Layer: <code>AbstractRangeReader</code>","text":"<p>This abstract class handles the boilerplate:</p> <ul> <li>Argument validation (bounds checks).</li> <li>Buffer handling (position management, slicing).</li> <li>Template pattern: delegates the actual byte fetching to <code>readRangeNoFlip</code>.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#backend-layer","title":"Backend Layer","text":"<p>These classes implement the actual network/disk I/O:</p> <ul> <li><code>FileRangeReader</code>: Wraps <code>FileChannel</code>. Uses OS page cache.</li> <li><code>HttpRangeReader</code>: Uses <code>java.net.http.HttpClient</code> to issue <code>GET</code> requests with <code>Range</code> headers.</li> <li><code>S3RangeReader</code>: Wraps AWS SDK v2. Maps exceptions to standard <code>IOException</code>.</li> <li><code>Azure</code> / <code>GCS</code>: Similar wrappers for their respective SDKs.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#decorator-layer","title":"Decorator Layer","text":"<p>We use the Decorator pattern to add behaviors without modifying backends.</p> <ul> <li><code>CachingRangeReader</code>: Intercepts <code>readRange</code>. Checks in-memory Caffeine cache. If miss, calls delegate, caches result, returns data.</li> <li><code>DiskCachingRangeReader</code>: Similar to above, but persists to a local file store.</li> <li><code>BlockAlignedRangeReader</code>: Expands arbitrary read requests (e.g., \"bytes 100-150\") to align with specific block boundaries (e.g., \"bytes 0-4096\"), optimizing cache hit rates.</li> </ul>"},{"location":"rangereader/developer-guide/architecture/#service-provider-interface-spi","title":"Service Provider Interface (SPI)","text":"<p>To support dynamic loading (e.g., for configuration-driven applications), we expose a <code>RangeReaderFactory</code>.</p> <ol> <li>Discovery: Uses <code>java.util.ServiceLoader</code> to find registered <code>RangeReaderProvider</code> implementations.</li> <li>Resolution: <code>RangeReaderFactory.create(uri)</code> iterates providers. The first one returning <code>true</code> for <code>canHandle(uri)</code> is instantiated.</li> <li>Extensibility: Users can write their own backend (e.g., <code>FtpRangeReader</code>) and register it via <code>META-INF/services</code> without forking the codebase.</li> </ol>"},{"location":"rangereader/developer-guide/architecture/#dependency-structure","title":"Dependency Structure","text":"<p>To avoid \"dependency hell\" (e.g., conflicting Netty versions between Azure and AWS SDKs), the core module has zero heavy dependencies.</p> <ul> <li><code>tileverse-rangereader-core</code>: Lightweight. Only depends on SLF4J and Caffeine.</li> <li><code>tileverse-rangereader-s3</code>: Pulls in AWS SDK.</li> <li><code>tileverse-rangereader-azure</code>: Pulls in Azure SDK.</li> </ul> <p>This allows consumers to pick exactly the providers they need.</p>"},{"location":"rangereader/developer-guide/building/","title":"Build System","text":"<p>This guide covers how to build, test, and install the library from source.</p>"},{"location":"rangereader/developer-guide/building/#development-environment","title":"Development Environment","text":"<ul> <li>JDK: Java 17 or later.</li> <li>Build Tool: Maven 3.9+.</li> <li>Docker: Required for running integration tests (Testcontainers).</li> </ul>"},{"location":"rangereader/developer-guide/building/#common-tasks","title":"Common Tasks","text":"<p>We provide a <code>Makefile</code> to simplify common development commands.</p>"},{"location":"rangereader/developer-guide/building/#building","title":"Building","text":"<pre><code># Clean compile\nmake compile\n\n# Build JARs (skipping tests)\nmake package\n</code></pre>"},{"location":"rangereader/developer-guide/building/#testing","title":"Testing","text":"<pre><code># Run unit tests\nmake test-unit\n\n# Run integration tests (requires Docker)\nmake test-it\n</code></pre>"},{"location":"rangereader/developer-guide/building/#code-quality","title":"Code Quality","text":"<p>We enforce strict formatting and style guidelines.</p> <pre><code># Check format\nmake lint\n\n# Fix format issues automatically\nmake format\n</code></pre>"},{"location":"rangereader/developer-guide/building/#maven-workflow","title":"Maven Workflow","text":"<p>If you prefer direct Maven commands:</p> <pre><code># Install to local repo\n./mvnw clean install -DskipTests\n\n# Run S3 integration tests only\n./mvnw verify -pl :tileverse-rangereader-s3\n</code></pre>"},{"location":"rangereader/developer-guide/building/#dependency-management","title":"Dependency Management","text":"<p>The project structure separates the core logic from heavy cloud SDKs.</p> <ul> <li><code>bom/</code>: Defines the Bill of Materials for version alignment.</li> <li><code>dependencies/</code>: Centralizes third-party versions (AWS, Azure, etc.).</li> </ul> <p>When adding a new dependency, add it to the <code>dependencies</code> module POM first, then reference it in the specific module without a version.</p>"},{"location":"rangereader/developer-guide/contributing/","title":"Contributing","text":"<p>Guidelines for contributing to the Tileverse Range Reader library.</p>"},{"location":"rangereader/developer-guide/contributing/#our-mission-unifying-the-java-geospatial-ecosystem","title":"Our Mission: Unifying the Java Geospatial Ecosystem","text":"<p>The Tileverse Range Reader project addresses a critical architectural gap in the Java ecosystem. We're building the unified I/O foundation that the geospatial community has needed\u2014a lightweight, extensible abstraction comparable to Python's fsspec library.</p>"},{"location":"rangereader/developer-guide/contributing/#strategic-impact","title":"Strategic Impact","text":"<p>Your contributions help solve real ecosystem problems:</p> <ul> <li>Reduce fragmentation: Every major Java geospatial library has implemented its own incompatible I/O solution</li> <li>Lower barriers: Make it easier for developers to build cloud-native format readers</li> <li>Improve performance: Enable consistent optimization patterns across the ecosystem</li> <li>Foster innovation: Provide a stable foundation for next-generation geospatial tools</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#ecosystem-integration-goals","title":"Ecosystem Integration Goals","text":"<p>We're actively working toward broader ecosystem adoption:</p> <ol> <li>Format Library Integration: Collaborating with projects like <code>imageio-ext</code> and <code>netCDF-Java</code> to consolidate around our unified API</li> <li>Community Standards: Proposing our patterns as community standards through organizations like LocationTech and OSGeo</li> <li>Cloud-Native Formats: Building reference implementations for PMTiles, GeoParquet, FlatGeobuf, and other emerging formats</li> <li>Framework Support: Ensuring compatibility with popular frameworks like GeoTools, Apache SIS, and GeoTrellis</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#getting-started","title":"Getting Started","text":""},{"location":"rangereader/developer-guide/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 21+ for development (Java 17+ for runtime)</li> <li>Maven 3.9+ for building and dependency management</li> <li>Docker for integration tests with TestContainers</li> <li>Git for version control</li> <li>IDE with Java support (IntelliJ IDEA, Eclipse, or VS Code)</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork and Clone:    <pre><code># Fork the repository on GitHub, then:\ngit clone https://github.com/YOUR_USERNAME/tileverse-rangereader.git\ncd tileverse-rangereader\n\n# Add upstream remote\ngit remote add upstream https://github.com/tileverse-io/tileverse-rangereader.git\n</code></pre></p> </li> <li> <p>Build and Test:    <pre><code># Build all modules\n./mvnw clean compile\n\n# Run unit tests\n./mvnw test\n\n# Run integration tests (requires Docker)\n./mvnw verify\n\n# Apply code formatting\n./mvnw spotless:apply\n</code></pre></p> </li> <li> <p>IDE Setup:</p> </li> <li>Import as Maven project</li> <li>Configure code style (Palantir Java Format)</li> <li>Enable annotation processing</li> <li>Set up run configurations for tests</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#contribution-types","title":"Contribution Types","text":""},{"location":"rangereader/developer-guide/contributing/#code-contributions","title":"Code Contributions","text":""},{"location":"rangereader/developer-guide/contributing/#new-features","title":"New Features","text":"<ul> <li>Add support for new storage backends</li> <li>Implement new optimization decorators</li> <li>Enhance existing functionality</li> <li>Add integration with cloud providers</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fix incorrect behavior</li> <li>Resolve performance issues</li> <li>Address security vulnerabilities</li> <li>Improve error handling</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Optimize hot code paths</li> <li>Improve caching strategies</li> <li>Reduce memory usage</li> <li>Enhance network efficiency</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#documentation-contributions","title":"Documentation Contributions","text":""},{"location":"rangereader/developer-guide/contributing/#user-documentation","title":"User Documentation","text":"<ul> <li>Usage examples and tutorials</li> <li>Configuration guides</li> <li>Troubleshooting information</li> <li>Best practices</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#developer-documentation","title":"Developer Documentation","text":"<ul> <li>API documentation improvements</li> <li>Architecture explanations</li> <li>Contributing guidelines</li> <li>Performance analysis</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#testing-contributions","title":"Testing Contributions","text":""},{"location":"rangereader/developer-guide/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Unit tests for new functionality</li> <li>Integration tests for cloud providers</li> <li>Performance benchmarks</li> <li>Edge case validation</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#test-infrastructure","title":"Test Infrastructure","text":"<ul> <li>TestContainers improvements</li> <li>CI/CD enhancements</li> <li>Test data generation</li> <li>Benchmark automation</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#code-contribution-process","title":"Code Contribution Process","text":""},{"location":"rangereader/developer-guide/contributing/#1-planning-your-contribution","title":"1. Planning Your Contribution","text":"<p>Before starting work:</p> <ol> <li>Check existing issues for similar work</li> <li>Create an issue if one doesn't exist</li> <li>Discuss your approach with maintainers</li> <li>Get feedback on design decisions</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#2-development-workflow","title":"2. Development Workflow","text":""},{"location":"rangereader/developer-guide/contributing/#create-a-feature-branch","title":"Create a Feature Branch","text":"<pre><code># Update your fork\ngit checkout main\ngit pull upstream main\ngit push origin main\n\n# Create feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#make-your-changes","title":"Make Your Changes","text":"<p>Follow these guidelines:</p> <ul> <li>Small, focused commits with clear messages</li> <li>Incremental development with working code at each step</li> <li>Follow existing patterns and conventions</li> <li>Write tests first when possible (TDD)</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commit format:</p> <pre><code>type(scope): brief description\n\nLonger description if needed\n\nFixes #123\n</code></pre> <p>Examples: <pre><code>feat(s3): add support for S3-compatible endpoints\nfix(cache): resolve memory leak in disk cache\ndocs(api): improve JavaDoc for RangeReader interface\ntest(azure): add integration tests for Azure authentication\n</code></pre></p>"},{"location":"rangereader/developer-guide/contributing/#3-code-quality-standards","title":"3. Code Quality Standards","text":""},{"location":"rangereader/developer-guide/contributing/#code-style","title":"Code Style","text":"<p>The project uses automated formatting and quality checks:</p> <pre><code># Apply code formatting\n./mvnw spotless:apply\n\n# Check formatting\n./mvnw spotless:check\n\n# Run all quality checks\n./mvnw validate\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#required-elements","title":"Required Elements","text":"<ol> <li>License Headers: All Java files must include Apache 2.0 license headers</li> <li>JavaDoc: Public APIs require comprehensive documentation</li> <li>Tests: All new functionality must have tests</li> <li>Thread Safety: All implementations must be thread-safe</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#code-review-checklist","title":"Code Review Checklist","text":"<ul> <li> Code follows project conventions</li> <li> All tests pass locally</li> <li> New functionality has tests</li> <li> Public APIs have JavaDoc</li> <li> Performance impact considered</li> <li> Thread safety maintained</li> <li> Error handling appropriate</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#4-testing-requirements","title":"4. Testing Requirements","text":""},{"location":"rangereader/developer-guide/contributing/#unit-tests","title":"Unit Tests","text":"<p>All new functionality requires unit tests:</p> <pre><code>@Test\nvoid testNewFeature() throws IOException {\n    // Given\n    RangeReader reader = createTestReader();\n\n    // When\n    ByteBuffer result = reader.readRange(0, 1024);\n\n    // Then\n    assertEquals(1024, result.remaining());\n    // Additional assertions...\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#integration-tests","title":"Integration Tests","text":"<p>New data sources require integration tests:</p> <pre><code>@Testcontainers\npublic class NewDataSourceIT extends AbstractRangeReaderIT {\n\n    @Container\n    static GenericContainer&lt;?&gt; testContainer = new GenericContainer&lt;&gt;(\"test-image:latest\")\n        .withExposedPorts(8080);\n\n    @Override\n    protected RangeReader createBaseReader() throws IOException {\n        return NewDataSourceReader.builder()\n            .endpoint(testContainer.getHost())\n            .port(testContainer.getMappedPort(8080))\n            .build();\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#performance-tests","title":"Performance Tests","text":"<p>Performance-sensitive changes need benchmarks:</p> <pre><code>@Test\nvoid testPerformanceRegression() throws IOException {\n    RangeReader reader = createOptimizedReader();\n\n    long startTime = System.nanoTime();\n    for (int i = 0; i &lt; 1000; i++) {\n        reader.readRange(i * 1024, 1024);\n    }\n    long endTime = System.nanoTime();\n\n    double durationMs = (endTime - startTime) / 1_000_000.0;\n    assertTrue(durationMs &lt; 1000, \"Performance regression detected\");\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#5-pull-request-process","title":"5. Pull Request Process","text":""},{"location":"rangereader/developer-guide/contributing/#before-submitting","title":"Before Submitting","text":"<pre><code># Rebase on latest main\ngit fetch upstream\ngit rebase upstream/main\n\n# Run full test suite\n./mvnw clean verify\n\n# Check formatting and quality\n./mvnw validate\n\n# Push to your fork\ngit push origin feature/your-feature-name\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#pull-request-description","title":"Pull Request Description","text":"<p>Include in your PR description:</p> <pre><code>## Summary\nBrief description of changes\n\n## Changes Made\n- List of specific changes\n- Any breaking changes\n- Performance impact\n\n## Testing\n- Types of tests added\n- How to test the changes\n- Test coverage information\n\n## Documentation\n- Documentation updated\n- Examples provided\n- Breaking changes documented\n\nFixes #issue-number\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI must pass</li> <li>Code Review: At least one maintainer approval</li> <li>Testing: Integration tests in CI environment</li> <li>Documentation: Verify docs are updated</li> <li>Merge: Squash and merge when approved</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"rangereader/developer-guide/contributing/#architecture-principles","title":"Architecture Principles","text":""},{"location":"rangereader/developer-guide/contributing/#1-decorator-pattern","title":"1. Decorator Pattern","text":"<p>All decorators follow the same pattern:</p> <pre><code>public class MyDecorator extends AbstractRangeReader {\n    private final RangeReader delegate;\n\n    public MyDecorator(RangeReader delegate) {\n        this.delegate = delegate;\n    }\n\n    @Override\n    protected int readRangeNoFlip(long offset, int length, ByteBuffer target) \n            throws IOException {\n        // Add decoration logic here\n        return delegate.readRange(offset, length, target);\n    }\n\n    @Override\n    public void close() throws IOException {\n        delegate.close();\n    }\n\n    public static Builder builder(RangeReader delegate) {\n        return new Builder(delegate);\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#2-builder-pattern","title":"2. Builder Pattern","text":"<p>All readers provide fluent builders:</p> <pre><code>public static class Builder {\n    private String endpoint;\n    private Duration timeout = Duration.ofSeconds(30);\n\n    public Builder endpoint(String endpoint) {\n        this.endpoint = endpoint;\n        return this;\n    }\n\n    public Builder timeout(Duration timeout) {\n        this.timeout = timeout;\n        return this;\n    }\n\n    public MyRangeReader build() {\n        return new MyRangeReader(endpoint, timeout);\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#3-thread-safety","title":"3. Thread Safety","text":"<p>All implementations must be thread-safe:</p> <pre><code>public class ThreadSafeReader extends AbstractRangeReader {\n    private final AtomicLong requestCount = new AtomicLong();\n    private final ConcurrentHashMap&lt;String, String&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    @Override\n    protected int readRangeNoFlip(long offset, int length, ByteBuffer target) \n            throws IOException {\n        requestCount.incrementAndGet();\n        // Thread-safe implementation\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"rangereader/developer-guide/contributing/#memory-management","title":"Memory Management","text":"<ul> <li>Use off-heap storage for large caches</li> <li>Implement proper cleanup in <code>close()</code> methods</li> <li>Avoid memory leaks in long-running applications</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#network-optimization","title":"Network Optimization","text":"<ul> <li>Minimize network requests through block alignment</li> <li>Use connection pooling for HTTP clients</li> <li>Implement retry logic with exponential backoff</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#caching-strategy","title":"Caching Strategy","text":"<ul> <li>Design cache keys for optimal hit rates</li> <li>Implement cache eviction policies</li> <li>Monitor cache performance metrics</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#error-handling","title":"Error Handling","text":""},{"location":"rangereader/developer-guide/contributing/#exception-types","title":"Exception Types","text":"<p>Use specific exception types:</p> <pre><code>// Good: Specific exception types\npublic class AuthenticationFailedException extends IOException {\n    public AuthenticationFailedException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n// Avoid: Generic exceptions\nthrow new RuntimeException(\"Something went wrong\");\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#error-context","title":"Error Context","text":"<p>Provide helpful error messages:</p> <pre><code>// Good: Contextual error information\nthrow new IOException(\n    \"Failed to read range [\" + offset + \", \" + (offset + length) + \") \" +\n    \"from \" + getSourceIdentifier() + \": \" + e.getMessage(), e);\n\n// Avoid: Unclear errors\nthrow new IOException(\"Read failed\", e);\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#retry-logic","title":"Retry Logic","text":"<p>Implement appropriate retry strategies:</p> <pre><code>public ByteBuffer readWithRetry(long offset, int length) throws IOException {\n    int attempts = 0;\n    while (attempts &lt; maxRetries) {\n        try {\n            return readRange(offset, length);\n        } catch (IOException e) {\n            if (isRetryable(e) &amp;&amp; attempts &lt; maxRetries - 1) {\n                attempts++;\n                sleep(calculateDelay(attempts));\n                continue;\n            }\n            throw e;\n        }\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"rangereader/developer-guide/contributing/#communication","title":"Communication","text":"<ul> <li>Be respectful and professional in all interactions</li> <li>Ask questions when you need clarification</li> <li>Share knowledge and help others learn</li> <li>Provide constructive feedback in code reviews</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#issue-reporting","title":"Issue Reporting","text":"<p>When reporting bugs:</p> <ol> <li>Search existing issues first</li> <li>Provide minimal reproduction case</li> <li>Include environment details (Java version, OS, etc.)</li> <li>Add relevant logs and stack traces</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#feature-requests","title":"Feature Requests","text":"<p>For new features:</p> <ol> <li>Explain the use case and motivation</li> <li>Discuss alternatives you've considered</li> <li>Provide implementation ideas if possible</li> <li>Consider compatibility with existing APIs</li> </ol>"},{"location":"rangereader/developer-guide/contributing/#recognition","title":"Recognition","text":""},{"location":"rangereader/developer-guide/contributing/#contributors","title":"Contributors","text":"<p>We recognize contributions through:</p> <ul> <li>Contributor list in documentation</li> <li>Release notes acknowledgment  </li> <li>GitHub contributor statistics</li> <li>Community spotlight for major contributions</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#maintainer-path","title":"Maintainer Path","text":"<p>Active contributors may be invited to become maintainers based on:</p> <ul> <li>Consistent quality contributions</li> <li>Community engagement and support</li> <li>Technical expertise in relevant areas</li> <li>Commitment to project goals</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#getting-help","title":"Getting Help","text":""},{"location":"rangereader/developer-guide/contributing/#resources","title":"Resources","text":"<ul> <li>Documentation: Start with user and developer guides</li> <li>Examples: Check the <code>examples/</code> directory</li> <li>Tests: Review existing tests for patterns</li> <li>Issues: Search GitHub issues for similar problems</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#contact","title":"Contact","text":"<ul> <li>GitHub Issues: For bugs and feature requests</li> <li>Discussions: For questions and ideas</li> <li>Email: For security issues and sensitive topics</li> <li>Discord/Slack: For real-time community chat (link in README)</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#mentorship","title":"Mentorship","text":"<p>New contributors can get help through:</p> <ul> <li>Good first issues: Labeled issues for beginners</li> <li>Mentoring: Experienced contributors provide guidance</li> <li>Pair programming: Virtual sessions for complex features</li> <li>Code review: Learning through the review process</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#legal","title":"Legal","text":""},{"location":"rangereader/developer-guide/contributing/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>By contributing, you agree that:</p> <ul> <li>Your contributions are your original work</li> <li>You grant the project rights to use your contributions</li> <li>Your contributions are under the Apache 2.0 license</li> <li>You have authority to make the contribution</li> </ul>"},{"location":"rangereader/developer-guide/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project follows a Code of Conduct that requires:</p> <ul> <li>Respectful communication with all participants</li> <li>Constructive feedback and criticism</li> <li>Inclusive behavior welcoming to all backgrounds</li> <li>Professional conduct in all project spaces</li> </ul> <p>Violations can be reported to project maintainers and will be addressed according to established procedures.</p>"},{"location":"rangereader/developer-guide/contributing/#api-stability","title":"API Stability","text":""},{"location":"rangereader/developer-guide/contributing/#stable-apis-semantic-versioning","title":"Stable APIs (Semantic Versioning)","text":"<p>The following APIs follow semantic versioning guarantees:</p> <ul> <li><code>RangeReader</code> interface: Core contract that won't change incompatibly</li> <li><code>AbstractRangeReader</code> public methods: Base implementation signatures  </li> <li>Builder public APIs: All builder methods and their behavior</li> <li>Core decorator classes: <code>CachingRangeReader</code>, <code>DiskCachingRangeReader</code></li> </ul> <p>Changes to these APIs require major version increments and migration guides.</p>"},{"location":"rangereader/developer-guide/contributing/#experimental-apis-subject-to-change","title":"Experimental APIs (Subject to Change)","text":"<p>The following may change between minor versions:</p> <ul> <li>Internal implementation details: Package-private classes and methods</li> <li>Benchmark and testing utilities: Performance testing infrastructure</li> <li>SPI interfaces: Service provider interfaces may evolve</li> <li>Configuration classes: Internal configuration objects</li> </ul> <p>When working with experimental APIs, expect potential changes and plan accordingly.</p>"},{"location":"rangereader/developer-guide/contributing/#next-steps","title":"Next Steps","text":"<p>Ready to contribute? Here's how to get started:</p> <ol> <li>Browse issues labeled \"good first issue\"</li> <li>Join discussions about features you're interested in</li> <li>Set up your development environment</li> <li>Start with documentation or small bug fixes</li> <li>Ask questions and engage with the community</li> </ol> <p>Your contributions help build the foundation for the next generation of cloud-native geospatial applications in Java. Welcome to the community! EOF &lt; /dev/null</p>"},{"location":"rangereader/developer-guide/performance/","title":"Performance Optimization","text":"<p>Understanding how <code>RangeReader</code> behaves under load is critical for high-throughput applications. This guide covers benchmarking and tuning.</p>"},{"location":"rangereader/developer-guide/performance/#benchmarking-methodology","title":"Benchmarking Methodology","text":"<p>We use JMH (Java Microbenchmark Harness) to measure performance. This ensures we avoid JVM warm-up pitfalls and get statistically significant results.</p>"},{"location":"rangereader/developer-guide/performance/#running-benchmarks","title":"Running Benchmarks","text":"<p>The <code>benchmarks</code> module contains pre-configured tests.</p> <pre><code># Build the benchmarks jar\nmvn clean package -pl benchmarks -am\n\n# Run S3 benchmarks\njava -jar benchmarks/target/benchmarks.jar S3RangeReaderBenchmark\n</code></pre>"},{"location":"rangereader/developer-guide/performance/#key-metrics","title":"Key Metrics","text":"<p>We primarily measure:</p> <ol> <li>Throughput (ops/sec): How many ranges can we read per second?</li> <li>Latency (p99): What is the worst-case time for a single read?</li> <li>Allocation Rate: How much garbage are we generating per read?</li> </ol>"},{"location":"rangereader/developer-guide/performance/#tuning-strategies","title":"Tuning Strategies","text":""},{"location":"rangereader/developer-guide/performance/#1-buffer-management","title":"1. Buffer Management","text":"<ul> <li> <p>Problem: Allocating a new <code>byte[]</code> or <code>ByteBuffer</code> for every read puts pressure on the Garbage Collector (GC).</p> </li> <li> <p>Solution: Use the <code>readRange(offset, length, targetBuffer)</code> overload. Reuse a thread-local or pooled <code>ByteBuffer</code>.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#2-connection-pooling","title":"2. Connection Pooling","text":"<ul> <li> <p>Problem: TLS handshakes are expensive. Creating a new S3/HTTP client for every request kills performance.</p> </li> <li> <p>Solution: The library pools connections by default. Ensure you reuse the <code>RangeReader</code> instance. Do not create a new <code>RangeReader</code> for every tile; create it once per file/session.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#3-block-alignment","title":"3. Block Alignment","text":"<ul> <li> <p>Problem: Cloud providers charge per request. Reading 10 bytes here and 10 bytes there generates many requests.</p> </li> <li> <p>Solution: Use <code>BlockAlignedRangeReader</code>. It effectively \"quantizes\" reads.</p> <ul> <li>Scenario: You read byte 10, then byte 20.</li> <li>Without Alignment: 2 network requests.</li> <li>With Alignment (4KB): Request 1 fetches 0-4096. Request 2 is served from cache.</li> </ul> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#4-read-coalescing","title":"4. Read Coalescing","text":"<ul> <li> <p>Concept: If an application requests bytes <code>0-100</code> and <code>100-200</code> in rapid succession (or concurrently), the reader can merge these into a single <code>0-200</code> request.</p> </li> <li> <p>Implementation: Currently handled via the <code>CachingRangeReader</code> and Block Alignment. Future versions may support explicit request coalescing for async patterns.</p> </li> </ul>"},{"location":"rangereader/developer-guide/performance/#cloud-considerations","title":"Cloud Considerations","text":"<ul> <li>AWS S3: The <code>S3RangeReader</code> uses the Apache HTTP client backend instead of Netty to reduce classpath conflicts. We tune the connection pool size to match standard concurrency levels (default 50).</li> <li>Latency: S3 Time-to-First-Byte (TTFB) is typically 50-100ms. Caching is mandatory for interactive performance.</li> </ul>"},{"location":"rangereader/developer-guide/testing/","title":"Testing","text":"<p>Comprehensive testing strategy and guidelines for the Tileverse Range Reader library.</p>"},{"location":"rangereader/developer-guide/testing/#testing-strategy","title":"Testing Strategy","text":"<p>The project employs a multi-layered testing approach:</p> <ul> <li>Unit Tests (<code>*Test.java</code>): Fast, isolated tests</li> <li>Integration Tests (<code>*IT.java</code>): End-to-end tests with real services</li> <li>Performance Tests (<code>*PerformanceTest.java</code>): Throughput and latency analysis</li> <li>Benchmarks: JMH-based comprehensive performance testing</li> </ul>"},{"location":"rangereader/developer-guide/testing/#test-categories","title":"Test Categories","text":""},{"location":"rangereader/developer-guide/testing/#unit-tests","title":"Unit Tests","text":"<p>Fast tests that verify individual components in isolation:</p> <pre><code># Run all unit tests (recommended)\nmake test-unit\n\n# Module-specific unit tests\nmake test-core     # Core module only\nmake test-s3       # S3 module only\nmake test-azure    # Azure module only\nmake test-gcs      # GCS module only\n\n# Direct Maven commands for specific test classes/methods\n./mvnw test -Dtest=\"CachingRangeReaderTest\"                    # Specific class\n./mvnw test -Dtest=\"CachingRangeReaderTest#testBasicCaching\"   # Specific method\n./mvnw test -pl src/core -Dtest=\"FileRangeReaderTest\"         # Class in specific module\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#example-unit-test","title":"Example Unit Test","text":"<pre><code>@Test\nvoid testBasicFileReading() throws IOException {\n    Path testFile = Files.createTempFile(\"test\", \".bin\");\n    Files.write(testFile, \"Hello, World!\".getBytes());\n\n    try (var reader = FileRangeReader.builder()\n            .path(testFile)\n            .build()) {\n\n        ByteBuffer result = reader.readRange(0, 5);\n        assertEquals(\"Hello\", new String(result.array(), 0, result.remaining()));\n    }\n\n    Files.deleteIfExists(testFile);\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#integration-tests","title":"Integration Tests","text":"<p>End-to-end tests using TestContainers for realistic scenarios:</p> <pre><code># Run all integration tests (recommended)\nmake test-it\n\n# Module-specific integration tests\nmake test-core-it  # Core integration tests (HTTP with Nginx)\nmake test-s3-it    # S3 integration tests (LocalStack + MinIO)\nmake test-azure-it # Azure integration tests (Azurite)\nmake test-gcs-it   # GCS integration tests\n\n# With TestContainers reuse for faster execution\nexport TESTCONTAINERS_REUSE_ENABLE=true\nmake test-it\n\n# Direct Maven commands for integration tests\n./mvnw verify -pl src/s3                # All S3 integration tests\n./mvnw verify -pl src/azure             # All Azure integration tests\n./mvnw verify -pl src/core              # All core integration tests\n./mvnw verify                           # All integration tests\n\n# For specific integration test classes (rarely needed)\n./mvnw test -pl src/s3 -Dtest=\"S3RangeReaderIT\"        # Specific S3 test\n./mvnw test -pl src/azure -Dtest=\"AzureBlobRangeReaderIT\" # Specific Azure test\n\n# Note: Module-specific make targets run ALL integration tests in that module\n# This is usually what you want for comprehensive testing\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#testcontainers-setup","title":"TestContainers Setup","text":"<p>All integration tests extend a common base class:</p> <pre><code>@Testcontainers(disabledWithoutDocker = true)\npublic class S3RangeReaderIT extends AbstractRangeReaderIT {\n\n    @Container\n    static LocalStackContainer localstack = new LocalStackContainer(\n            DockerImageName.parse(\"localstack/localstack:3.2.0\"))\n        .withServices(LocalStackContainer.Service.S3);\n\n    @Override\n    protected RangeReader createBaseReader() throws IOException {\n        return S3RangeReader.builder()\n            .endpointOverride(localstack.getEndpoint())\n            .region(Region.of(localstack.getRegion()))\n            .build();\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#performance-tests","title":"Performance Tests","text":"<p>Measure performance characteristics under various conditions:</p> <pre><code># Run performance tests (recommended)\nmake perf-test\n\n# Direct Maven commands\n./mvnw test -Dtest=\"*PerformanceTest\"                                   # All performance tests\n./mvnw test -Dtest=\"RangeReaderPerformanceTest\" -Dperformance.iterations=1000  # With custom parameters\n./mvnw test -pl src/core -Dtest=\"*PerformanceTest\"                    # Module-specific\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#example-performance-test","title":"Example Performance Test","text":"<pre><code>@Test\nvoid testLargeFilePerformance() throws IOException {\n    Path largeFile = createLargeTestFile(100 * 1024 * 1024); // 100MB\n\n    try (var reader = FileRangeReader.builder()\n            .path(largeFile)\n            .build()) {\n\n        long startTime = System.nanoTime();\n\n        // Read 1000 random ranges\n        for (int i = 0; i &lt; 1000; i++) {\n            long offset = ThreadLocalRandom.current().nextLong(largeFile.toFile().length() - 1024);\n            reader.readRange(offset, 1024);\n        }\n\n        long endTime = System.nanoTime();\n        double durationMs = (endTime - startTime) / 1_000_000.0;\n\n        System.out.println(\"1000 reads took \" + durationMs + \"ms\");\n        assertTrue(durationMs &lt; 10000, \"Performance regression detected\");\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#base-test-classes","title":"Base Test Classes","text":""},{"location":"rangereader/developer-guide/testing/#abstractrangereaderit","title":"AbstractRangeReaderIT","text":"<p>All integration tests extend this base class to ensure consistent behavior:</p> <pre><code>public abstract class AbstractRangeReaderIT {\n    protected static final int TEST_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\n    protected abstract RangeReader createBaseReader() throws IOException;\n\n    @Test\n    void testBasicRangeReading() throws IOException {\n        try (RangeReader reader = createBaseReader()) {\n            ByteBuffer data = reader.readRange(0, 1024);\n            assertEquals(1024, data.remaining());\n        }\n    }\n\n    @Test\n    void testBoundaryConditions() throws IOException {\n        try (RangeReader reader = createBaseReader()) {\n            long size = reader.size();\n\n            // Test reading at EOF\n            ByteBuffer data = reader.readRange(size - 10, 20);\n            assertEquals(10, data.remaining());\n\n            // Test reading beyond EOF\n            ByteBuffer empty = reader.readRange(size + 100, 1024);\n            assertEquals(0, empty.remaining());\n        }\n    }\n\n    // More common test cases...\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#testcontainers-integration","title":"TestContainers Integration","text":""},{"location":"rangereader/developer-guide/testing/#available-test-containers","title":"Available Test Containers","text":"Service Container Purpose S3 <code>localstack/localstack:3.2.0</code> AWS S3 API emulation MinIO <code>minio/minio:latest</code> S3-compatible storage Azure <code>mcr.microsoft.com/azure-storage/azurite:latest</code> Azure Blob Storage HTTP <code>nginx:alpine</code> HTTP server with authentication"},{"location":"rangereader/developer-guide/testing/#container-configuration-examples","title":"Container Configuration Examples","text":""},{"location":"rangereader/developer-guide/testing/#localstack-s3","title":"LocalStack (S3)","text":"<pre><code>@Container\nstatic LocalStackContainer localstack = new LocalStackContainer(\n        DockerImageName.parse(\"localstack/localstack:3.2.0\"))\n    .withServices(LocalStackContainer.Service.S3)\n    .withEnv(\"DEBUG\", \"1\");\n\n@BeforeAll\nstatic void setupS3() throws IOException {\n    S3Client s3Client = S3Client.builder()\n        .endpointOverride(localstack.getEndpoint())\n        .region(Region.of(localstack.getRegion()))\n        .credentialsProvider(StaticCredentialsProvider.create(\n            AwsBasicCredentials.create(\n                localstack.getAccessKey(), \n                localstack.getSecretKey())))\n        .build();\n\n    s3Client.createBucket(CreateBucketRequest.builder()\n        .bucket(\"test-bucket\")\n        .build());\n\n    // Upload test file\n    s3Client.putObject(\n        PutObjectRequest.builder()\n            .bucket(\"test-bucket\")\n            .key(\"test-file.bin\")\n            .build(),\n        RequestBody.fromFile(testFile));\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#minio","title":"MinIO","text":"<pre><code>@Container\nstatic MinIOContainer minio = new MinIOContainer(\"minio/minio:latest\");\n\n@BeforeAll\nstatic void setupMinIO() throws IOException {\n    S3Client s3Client = S3Client.builder()\n        .endpointOverride(URI.create(minio.getS3URL()))\n        .region(Region.US_EAST_1)\n        .credentialsProvider(StaticCredentialsProvider.create(\n            AwsBasicCredentials.create(\n                minio.getUserName(), \n                minio.getPassword())))\n        .forcePathStyle(true)\n        .build();\n\n    // Create bucket and upload test data\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#azurite-azure-blob-storage","title":"Azurite (Azure Blob Storage)","text":"<pre><code>@Container\nstatic GenericContainer&lt;?&gt; azurite = new GenericContainer&lt;&gt;(\"mcr.microsoft.com/azure-storage/azurite:latest\")\n    .withExposedPorts(10000)\n    .withCommand(\"azurite-blob\", \"--blobHost\", \"0.0.0.0\");\n\n@BeforeAll\nstatic void setupAzure() throws IOException {\n    String connectionString = String.format(\n        \"DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;\" +\n        \"AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;\" +\n        \"BlobEndpoint=http://%s:%d/devstoreaccount1;\",\n        azurite.getHost(), azurite.getMappedPort(10000));\n\n    BlobServiceClient blobClient = new BlobServiceClientBuilder()\n        .connectionString(connectionString)\n        .buildClient();\n\n    // Create container and upload test data\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#test-utilities","title":"Test Utilities","text":""},{"location":"rangereader/developer-guide/testing/#testutil-class","title":"TestUtil Class","text":"<p>Common utilities for creating test data:</p> <pre><code>public class TestUtil {\n\n    public static Path createTempTestFile(int sizeBytes) throws IOException {\n        Path testFile = Files.createTempFile(\"rangereader-test\", \".bin\");\n\n        // Create deterministic test data\n        byte[] data = new byte[sizeBytes];\n        Random random = new Random(42); // Fixed seed for reproducibility\n        random.nextBytes(data);\n\n        Files.write(testFile, data);\n        return testFile;\n    }\n\n    public static void verifyRangeContent(ByteBuffer actual, byte[] expected, \n                                         int offset, int length) {\n        assertEquals(length, actual.remaining());\n\n        for (int i = 0; i &lt; length; i++) {\n            assertEquals(expected[offset + i], actual.get(i),\n                \"Mismatch at position \" + i);\n        }\n    }\n\n    public static byte[] generateTestData(int size, long seed) {\n        byte[] data = new byte[size];\n        Random random = new Random(seed);\n        random.nextBytes(data);\n        return data;\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"rangereader/developer-guide/testing/#consistent-test-data","title":"Consistent Test Data","text":"<p>All tests use the same deterministic test data:</p> <pre><code>public class AbstractRangeReaderIT {\n    protected static final int TEST_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n    protected static final long TEST_DATA_SEED = 42L;\n\n    protected static byte[] createExpectedData() {\n        return TestUtil.generateTestData(TEST_FILE_SIZE, TEST_DATA_SEED);\n    }\n\n    @Test\n    void testRangeConsistency() throws IOException {\n        byte[] expectedData = createExpectedData();\n\n        try (RangeReader reader = createBaseReader()) {\n            // Test various ranges\n            verifyRange(reader, expectedData, 0, 1024);\n            verifyRange(reader, expectedData, 5000, 2048);\n            verifyRange(reader, expectedData, TEST_FILE_SIZE - 1000, 1000);\n        }\n    }\n\n    private void verifyRange(RangeReader reader, byte[] expected, \n                           int offset, int length) throws IOException {\n        ByteBuffer actual = reader.readRange(offset, length);\n        TestUtil.verifyRangeContent(actual, expected, offset, length);\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#benchmarks-with-jmh","title":"Benchmarks with JMH","text":""},{"location":"rangereader/developer-guide/testing/#running-benchmarks","title":"Running Benchmarks","text":"<pre><code># Build and run benchmarks (recommended)\nmake build-benchmarks  # Build benchmark JAR\nmake benchmarks        # Run all benchmarks\n\n# Specific benchmark types\nmake benchmarks-file   # Run file-based benchmarks only\nmake benchmarks-gc     # Run benchmarks with GC profiling\n\n# Build cloud benchmarks (requires TestContainers)\nmake benchmarks-cloud\n\n# Direct execution\njava -jar benchmarks/target/benchmarks.jar                    # All benchmarks\njava -jar benchmarks/target/benchmarks.jar FileRangeReader    # Specific benchmark\njava -jar benchmarks/target/benchmarks.jar -prof gc           # With profiling\njava -jar benchmarks/target/benchmarks.jar -f 3 -wi 5 -i 10   # Custom parameters\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#example-benchmark","title":"Example Benchmark","text":"<pre><code>@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.SECONDS)\n@State(Scope.Benchmark)\npublic class FileRangeReaderBenchmark {\n\n    private RangeReader reader;\n    private ByteBuffer buffer;\n\n    @Setup\n    public void setup() throws IOException {\n        Path testFile = TestUtil.createTempTestFile(100 * 1024 * 1024);\n        reader = FileRangeReader.builder()\n            .path(testFile)\n            .build();\n        buffer = ByteBuffer.allocate(64 * 1024);\n    }\n\n    @Benchmark\n    public int sequentialReads() throws IOException {\n        buffer.clear();\n        return reader.readRange(ThreadLocalRandom.current().nextLong(1024 * 1024), \n                               64 * 1024, buffer);\n    }\n\n    @TearDown\n    public void tearDown() throws IOException {\n        reader.close();\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"rangereader/developer-guide/testing/#test-organization","title":"Test Organization","text":"<pre><code>class CachingRangeReaderTest {\n\n    @Nested\n    @DisplayName(\"Basic Functionality\")\n    class BasicFunctionality {\n        @Test void testCacheHit() { }\n        @Test void testCacheMiss() { }\n    }\n\n    @Nested\n    @DisplayName(\"Configuration\")\n    class Configuration {\n        @Test void testMaximumSize() { }\n        @Test void testExpiration() { }\n    }\n\n    @Nested\n    @DisplayName(\"Error Handling\")\n    class ErrorHandling {\n        @Test void testDelegateFailure() { }\n        @Test void testInvalidParameters() { }\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#parameterized-tests","title":"Parameterized Tests","text":"<pre><code>@ParameterizedTest\n@ValueSource(ints = {100, 1000, 10000})\nvoid testVariousCacheSizes(int cacheSize) throws IOException {\n    try (var reader = CachingRangeReader.builder(baseReader)\n            .maximumSize(cacheSize)\n            .build()) {\n\n        ByteBuffer data = reader.readRange(100, 500);\n        assertEquals(500, data.remaining());\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#test-resource-management","title":"Test Resource Management","text":"<pre><code>@TempDir\nPath tempDir;\n\n@Test\nvoid testWithTempDirectory() throws IOException {\n    Path testFile = tempDir.resolve(\"test.bin\");\n    Files.write(testFile, \"test data\".getBytes());\n\n    try (var reader = FileRangeReader.builder()\n            .path(testFile)\n            .build()) {\n        // Test operations\n    }\n    // File automatically cleaned up by @TempDir\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"rangereader/developer-guide/testing/#github-actions-testing","title":"GitHub Actions Testing","text":"<p>The project runs comprehensive tests in CI using Makefile targets:</p> <pre><code># .github/workflows/pr-validation.yml\njobs:\n  build:\n    strategy:\n      matrix:\n        java-version: ['17', '21', '24']\n    steps:\n      - name: Run unit tests\n        run: make test-unit\n\n  integration-tests:\n    strategy:\n      matrix:\n        java-version: ['17', '21', '24']\n        test-group: ['core', 's3', 'azure', 'gcs']\n    steps:\n      - name: Run integration tests\n        run: make test-${{ matrix.test-group }}-it\n\n  quality:\n    steps:\n      - name: Check formatting\n        run: make lint\n      - name: Full verification\n        run: make verify\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#test-parallelization","title":"Test Parallelization","text":"<pre><code># TestContainers reuse for faster integration tests (recommended)\nexport TESTCONTAINERS_REUSE_ENABLE=true\nmake test-it\n\n# Module-specific integration tests with reuse\nexport TESTCONTAINERS_REUSE_ENABLE=true\nmake test-s3-it\n\n# Direct Maven commands for parallel execution\n./mvnw test -Dparallel=classes -DthreadCount=4  # Parallel unit tests\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"rangereader/developer-guide/testing/#test-logging","title":"Test Logging","text":"<pre><code>// Enable debug logging for tests\n@TestMethodOrder(OrderAnnotation.class)\nclass DebugTest {\n\n    @BeforeEach\n    void setupLogging() {\n        System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", \"DEBUG\");\n        System.setProperty(\"org.slf4j.simpleLogger.log.io.tileverse.rangereader\", \"TRACE\");\n    }\n}\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#ide-test-configuration","title":"IDE Test Configuration","text":""},{"location":"rangereader/developer-guide/testing/#intellij-idea","title":"IntelliJ IDEA","text":"<pre><code>Run Configuration:\n- Working directory: $MODULE_WORKING_DIR$\n- VM options: -ea -Dtestcontainers.reuse.enable=true\n- Environment variables: TESTCONTAINERS_REUSE_ENABLE=true\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#eclipse","title":"Eclipse","text":"<pre><code>Run Configuration:\n- Arguments tab \u2192 VM arguments: -ea\n- Environment tab \u2192 Add: TESTCONTAINERS_REUSE_ENABLE=true\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#test-coverage","title":"Test Coverage","text":""},{"location":"rangereader/developer-guide/testing/#measuring-coverage","title":"Measuring Coverage","text":"<pre><code># Generate coverage report\n./mvnw test jacoco:report\n\n# View coverage report\nopen target/site/jacoco/index.html\n</code></pre>"},{"location":"rangereader/developer-guide/testing/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Line Coverage: &gt; 85%</li> <li>Branch Coverage: &gt; 80%</li> <li>Method Coverage: &gt; 90%</li> </ul>"},{"location":"rangereader/developer-guide/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Performance: Learn about performance testing and optimization</li> <li>Contributing: Guidelines for contributing tests</li> <li>Building: Build system and test execution</li> </ul>"},{"location":"rangereader/user-guide/","title":"User Guide","text":"<p>Welcome to the Tileverse Range Reader User Guide! This section provides comprehensive guidance for developers who want to integrate the library into their applications.</p>"},{"location":"rangereader/user-guide/#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers everything you need to know to effectively use the Tileverse Range Reader library:</p> <ul> <li>Installation: How to add the library to your project</li> <li>Quick Start: Get up and running with basic examples</li> <li>Configuration: Advanced configuration options for optimal performance</li> <li>Authentication: Setting up authentication for cloud providers and HTTP sources</li> <li>Troubleshooting: Common issues and their solutions</li> </ul>"},{"location":"rangereader/user-guide/#real-world-use-cases","title":"Real-World Use Cases","text":"<p>The Tileverse Range Reader library addresses critical needs in modern geospatial and data processing applications:</p>"},{"location":"rangereader/user-guide/#geospatial-data-processing","title":"\ud83c\udf0d Geospatial Data Processing","text":"<ul> <li>Cloud Optimized GeoTIFF (COG) reading for satellite imagery analysis</li> <li>PMTiles serving for high-performance web mapping</li> <li>GeoParquet processing for large-scale vector analytics</li> <li>Zarr access for multi-dimensional geospatial datasets</li> <li>FlatGeobuf streaming for efficient vector data queries</li> </ul>"},{"location":"rangereader/user-guide/#enterprise-applications","title":"\ud83c\udfe2 Enterprise Applications","text":"<ul> <li>Server-side tile rendering without downloading entire datasets</li> <li>Microservices architecture with cloud-native data access</li> <li>Data pipelines that process specific portions of large files</li> <li>Analytics platforms performing random access on cloud-stored data</li> </ul>"},{"location":"rangereader/user-guide/#performance-critical-systems","title":"\ud83d\ude80 Performance-Critical Systems","text":"<ul> <li>Real-time mapping applications requiring sub-second response times</li> <li>Large-scale batch processing with optimized I/O patterns</li> <li>Mobile and embedded systems with bandwidth constraints</li> <li>Multi-tenant platforms with shared caching strategies</li> </ul>"},{"location":"rangereader/user-guide/#target-audience","title":"Target Audience","text":"<p>This guide is designed for:</p> <ul> <li>Java Developers building geospatial or data processing applications</li> <li>Application Architects designing cloud-native data access systems</li> <li>DevOps Engineers deploying and optimizing data-intensive applications</li> <li>Performance Engineers optimizing I/O patterns and caching strategies</li> <li>Library Authors building format readers on a common foundation</li> </ul>"},{"location":"rangereader/user-guide/#prerequisites","title":"Prerequisites","text":"<p>Before using this library, you should have:</p> <ul> <li>Java 17+ installed and configured</li> <li>Maven 3.9+ for dependency management</li> <li>Basic familiarity with Java NIO and ByteBuffer operations</li> <li>Understanding of your target data sources (local files, HTTP, cloud storage)</li> </ul>"},{"location":"rangereader/user-guide/#getting-started-quickly","title":"Getting Started Quickly","text":"<p>If you're in a hurry, start with these essentials:</p> <ol> <li>Installation - Add the library to your project</li> <li>Quick Start - Basic usage examples</li> <li>Configuration - Performance optimization</li> </ol>"},{"location":"rangereader/user-guide/#library-overview","title":"Library Overview","text":"<p>The Tileverse Range Reader provides a unified interface for reading byte ranges from various sources:</p> <pre><code>// The core interface - same for all data sources\npublic interface RangeReader extends Closeable {\n    ByteBuffer readRange(long offset, int length) throws IOException;\n    int readRange(long offset, int length, ByteBuffer target) throws IOException;\n    long size() throws IOException;\n    String getSourceIdentifier();\n}\n</code></pre>"},{"location":"rangereader/user-guide/#supported-data-sources","title":"Supported Data Sources","text":"Data Source Module Authentication Local Files <code>core</code> File system permissions HTTP/HTTPS <code>core</code> Basic, Bearer, API Key, Digest, Custom Amazon S3 <code>s3</code> AWS credentials, IAM roles Azure Blob Storage <code>azure</code> Connection strings, SAS tokens, Azure AD Google Cloud Storage <code>gcs</code> Service accounts, ADC"},{"location":"rangereader/user-guide/#performance-features","title":"Performance Features","text":"<p>The library includes several performance optimization features:</p> <ul> <li>Memory Caching: Fast access to recently used ranges</li> <li>Disk Caching: Persistent caching for large datasets</li> <li>Block Alignment: Optimized read patterns for cloud storage</li> <li>Concurrent Access: Thread-safe implementations</li> </ul>"},{"location":"rangereader/user-guide/#common-use-cases","title":"Common Use Cases","text":""},{"location":"rangereader/user-guide/#pmtiles-and-tiled-data","title":"PMTiles and Tiled Data","text":"<p>Perfect for accessing tile data without loading entire files:</p> <pre><code>// Read PMTiles header\nByteBuffer header = reader.readRange(0, 127);\nheader.flip();\n\n// Read specific tiles based on tile index\nByteBuffer tileData = reader.readRange(tileOffset, tileLength);\ntileData.flip();\n</code></pre>"},{"location":"rangereader/user-guide/#large-file-processing","title":"Large File Processing","text":"<p>Process large files in chunks:</p> <pre><code>long fileSize = reader.size();\nint chunkSize = 1024 * 1024; // 1MB chunks\n\nfor (long offset = 0; offset &lt; fileSize; offset += chunkSize) {\n    int length = (int) Math.min(chunkSize, fileSize - offset);\n    ByteBuffer chunk = reader.readRange(offset, length);\n    chunk.flip();\n    // Process chunk\n}\n</code></pre>"},{"location":"rangereader/user-guide/#cloud-data-analysis","title":"Cloud Data Analysis","text":"<p>Efficiently access cloud-stored datasets:</p> <pre><code>// Read dataset metadata\nByteBuffer metadata = reader.readRange(0, 1024);\nmetadata.flip();\n\n// Read specific data sections\nByteBuffer section1 = reader.readRange(metadataSize, sectionLength);\nsection1.flip();\nByteBuffer section2 = reader.readRange(section1Offset, section1Length);\nsection2.flip();\n</code></pre>"},{"location":"rangereader/user-guide/#performance-considerations","title":"Performance Considerations","text":""},{"location":"rangereader/user-guide/#decorator-stacking-order","title":"Decorator Stacking Order","text":"<p>For optimal performance, stack decorators in this order:</p> <pre><code>Application\n    \u2193\nCachingRangeReader (memory cache - outermost)\n    \u2193  \nDiskCachingRangeReader (persistent cache)\n    \u2193\nBaseReader (S3, Azure, HTTP, etc.)\n    \u2193\nData Source\n</code></pre>"},{"location":"rangereader/user-guide/#read-pattern-guidelines","title":"Read Pattern Guidelines","text":"Data Source Recommended Strategy Rationale Local Files Direct access OS already provides efficient file caching HTTP Chunked reading (256 KB - 1 MB) Reduce request overhead S3 Large chunks (1 MB - 8 MB) Minimize API calls, optimize for S3's performance characteristics Azure Blob Large chunks (1 MB - 4 MB) Balance throughput and latency Google Cloud Large chunks (1 MB - 8 MB) Optimize for GCS performance"},{"location":"rangereader/user-guide/#memory-management","title":"Memory Management","text":"<p>Configure caching based on your available memory:</p> <pre><code>// For memory-constrained environments\nCachingRangeReader.builder(delegate)\n    .maximumSize(100)  // Limit number of cached ranges\n    .softValues()      // Allow GC to reclaim memory\n    .build()\n\n// For memory-rich environments  \nCachingRangeReader.builder(delegate)\n    .maxSizeBytes(512 * 1024 * 1024)  // 512MB cache\n    .expireAfterAccess(30, TimeUnit.MINUTES)\n    .build()\n</code></pre>"},{"location":"rangereader/user-guide/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Choose your path:</p> <ul> <li> <p> Installation</p> <p>Add the library to your Maven project</p> <p> Install</p> </li> <li> <p> Quick Start</p> <p>Basic examples for each data source</p> <p> Examples</p> </li> <li> <p> Configuration</p> <p>Optimize performance for your use case</p> <p> Configure</p> </li> <li> <p> Authentication</p> <p>Set up secure access to your data</p> <p> Auth Setup</p> </li> </ul>"},{"location":"rangereader/user-guide/#need-help","title":"Need Help?","text":"<ul> <li>Check the Troubleshooting guide for common issues</li> <li>Review the Quick Start for code examples</li> <li>Read the Configuration guide for advanced setup</li> <li>Visit our GitHub repository for the latest updates</li> </ul>"},{"location":"rangereader/user-guide/authentication/","title":"Authentication Setup","text":"<p>This guide details how to configure credentials for cloud storage and secure HTTP endpoints.</p>"},{"location":"rangereader/user-guide/authentication/#http-sources","title":"HTTP Sources","text":"<p>The <code>HttpRangeReader</code> supports standard authentication schemes via builder methods or property configuration.</p>"},{"location":"rangereader/user-guide/authentication/#basic-auth","title":"Basic Auth","text":"<p>For simple username/password protection.</p> BuilderProperties <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://secure.example.com/data.bin\"))\n    .basicAuth(\"user\", \"pass\")\n    .build();\n</code></pre> <pre><code>var props = new Properties();\nprops.setProperty(\"io.tileverse.rangereader.http.username\", \"user\");\nprops.setProperty(\"io.tileverse.rangereader.http.password\", \"pass\");\n\nvar reader = RangeReaderFactory.create(uri, props);\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#bearer-tokens","title":"Bearer Tokens","text":"<p>Commonly used with OAuth2 and JWT.</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://api.example.com/data\"))\n    .bearerToken(System.getenv(\"API_TOKEN\"))\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#custom-headers-api-keys","title":"Custom Headers / API Keys","text":"<p>For services requiring specific header schemes (e.g., <code>X-API-Key</code>).</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(URI.create(\"https://api.provider.com/data\"))\n    // Arguments: Header Name, Value, Prefix (optional)\n    .apiKey(\"X-Custom-Auth\", \"secret-key-123\", null) \n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#aws-s3","title":"AWS S3","text":"<p>The <code>S3RangeReader</code> integrates with the standard AWS SDK default credential chain.</p>"},{"location":"rangereader/user-guide/authentication/#default-discovery-order","title":"Default Discovery Order","text":"<p>The library attempts to find credentials in the following order (standard AWS behavior):</p> <ol> <li>Environment Variables (<code>AWS_ACCESS_KEY_ID</code>, etc.)</li> <li>System Properties (<code>aws.accessKeyId</code>, etc.)</li> <li>Web Identity Token (for EKS/K8s)</li> <li><code>~/.aws/credentials</code> file</li> <li>EC2 Instance Profile</li> </ol>"},{"location":"rangereader/user-guide/authentication/#explicit-configuration","title":"Explicit Configuration","text":"<p>To force a specific credential provider or profile:</p> <pre><code>// Use a specific profile from ~/.aws/credentials\nvar profileParams = ProfileCredentialsProvider.create(\"production\");\n\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/map.pmtiles\"))\n    .credentialsProvider(profileParams)\n    .region(Region.US_EAST_1)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#assume-role-sts","title":"Assume Role (STS)","text":"<p>To access cross-account resources via STS:</p> <pre><code>var stsClient = StsClient.builder().region(Region.US_EAST_1).build();\n\nvar roleProvider = StsAssumeRoleCredentialsProvider.builder()\n    .stsClient(stsClient)\n    .refreshRequest(req -&gt; req\n        .roleArn(\"arn:aws:iam::123456789012:role/CrossAccountAccess\")\n        .roleSessionName(\"tileverse-session\"))\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://external-bucket/data\"))\n    .credentialsProvider(roleProvider)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#azure-blob-storage","title":"Azure Blob Storage","text":""},{"location":"rangereader/user-guide/authentication/#sas-token-recommended","title":"SAS Token (Recommended)","text":"<p>Shared Access Signatures provide granular control over access.</p> <pre><code>// Token typically generated by a backend service\nvar sasToken = \"sv=2020-08-04&amp;ss=b&amp;srt=o&amp;sp=r&amp;se=2024-01-01...\";\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .sasToken(sasToken)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#connection-string","title":"Connection String","text":"<p>Useful for server-side applications with full access keys.</p> <pre><code>var conn = \"DefaultEndpointsProtocol=https;AccountName=...;AccountKey=...\";\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .connectionString(conn)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#managed-identity","title":"Managed Identity","text":"<p>For applications running within Azure infrastructure (VMs, App Service, AKS).</p> <pre><code>var credential = new DefaultAzureCredentialBuilder().build();\n\nvar reader = AzureBlobRangeReader.builder()\n    .uri(URI.create(\"https://account.blob.core.windows.net/container/blob\"))\n    .credential(credential)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#google-cloud-storage-gcs","title":"Google Cloud Storage (GCS)","text":""},{"location":"rangereader/user-guide/authentication/#application-default-credentials-adc","title":"Application Default Credentials (ADC)","text":"<p>Recommended for most environments. The library automatically looks for:</p> <ol> <li><code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable.</li> <li>Credentials set via <code>gcloud auth application-default login</code>.</li> <li>Attached Service Account (GCE, GKE, Cloud Run).</li> </ol> <pre><code>// No extra config needed if ADC is set up\nvar reader = GoogleCloudStorageRangeReader.builder()\n    .uri(URI.create(\"gs://my-bucket/data\"))\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/authentication/#service-account-key-json","title":"Service Account Key (JSON)","text":"<p>If you need to manually load a key file:</p> <pre><code>try (var input = new FileInputStream(\"/path/to/key.json\")) {\n    var creds = ServiceAccountCredentials.fromStream(input);\n\n    var reader = GoogleCloudStorageRangeReader.builder()\n        .uri(URI.create(\"gs://my-bucket/data\"))\n        .credentials(creds)\n        .build();\n}\n</code></pre>"},{"location":"rangereader/user-guide/configuration/","title":"Performance Configuration","text":"<p>This guide covers how to tune the <code>RangeReader</code> for different workloads, such as random access (tiles), sequential processing (ETL), or high-latency environments.</p>"},{"location":"rangereader/user-guide/configuration/#caching-layers","title":"Caching Layers","text":"<p>Caching is critical when reading from remote sources (S3, HTTP) to minimize latency and cost.</p>"},{"location":"rangereader/user-guide/configuration/#memory-cache-cachingrangereader","title":"Memory Cache (<code>CachingRangeReader</code>)","text":"<p>Best for: Random access, Tile servers, Metadata headers.</p> <pre><code>var s3Reader = S3RangeReader.builder().uri(uri).build();\n\nvar cachedReader = CachingRangeReader.builder(s3Reader)\n    // Strategy 1: Max entries (good for header/directory blocks)\n    .maximumSize(1000)\n\n    // Strategy 2: Max memory (e.g., 128MB)\n    .maxSizeBytes(128L * 1024 * 1024)\n\n    // Strategy 3: Expiration\n    .expireAfterAccess(10, TimeUnit.MINUTES)\n\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#disk-cache-diskcachingrangereader","title":"Disk Cache (<code>DiskCachingRangeReader</code>)","text":"<p>Best for: Large datasets, Repeated runs, Offline capability.</p> <pre><code>var diskCachedReader = DiskCachingRangeReader.builder(s3Reader)\n    .cacheDirectory(Path.of(\"/mnt/fast-ssd/cache\"))\n    // Hard limit on disk usage (e.g., 10GB)\n    .maxCacheSizeBytes(10L * 1024 * 1024 * 1024)\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#read-optimization","title":"Read Optimization","text":""},{"location":"rangereader/user-guide/configuration/#block-alignment","title":"Block Alignment","text":"<p>Cloud storage APIs (S3, GCS) often perform better (and cost less) when reading aligned blocks rather than many tiny, fragmented ranges.</p> <pre><code>// Align reads to 64KB boundaries\nvar alignedReader = BlockAlignedRangeReader.builder(reader)\n    .blockSize(64 * 1024) \n    .build();\n</code></pre> <p>Impact: If you request bytes <code>100-200</code>, the reader fetches <code>0-65536</code>. If you essentially request <code>200-300</code>, it's served from memory/disk cache immediately.</p>"},{"location":"rangereader/user-guide/configuration/#provider-specific-tuning","title":"Provider-Specific Tuning","text":""},{"location":"rangereader/user-guide/configuration/#amazon-s3","title":"Amazon S3","text":"<p>Using the native AWS SDK client allows for deep configuration:</p> <pre><code>var s3Client = S3Client.builder()\n    .region(Region.US_WEST_2)\n    .httpClient(ApacheHttpClient.builder()\n        .maxConnections(50)\n        .socketTimeout(Duration.ofSeconds(10))\n        .build())\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .client(s3Client)\n    .bucket(\"maps\")\n    .key(\"planet.pmtiles\")\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#http-https","title":"HTTP / HTTPS","text":"<p>You can tune the underlying HTTP connection pool and timeouts:</p> <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .connectTimeout(Duration.ofSeconds(5))\n    .readTimeout(Duration.ofSeconds(30))\n    // Enable GZIP if the server supports range requests with compression\n    .compressionEnabled(true) \n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#global-properties","title":"Global Properties","text":"<p>For environments where code changes are difficult, you can configure defaults via system properties:</p> Property Description Default <code>io.tileverse.rangereader.http.timeout-millis</code> Global HTTP timeout 5000 <code>io.tileverse.rangereader.http.trust-all-certificates</code> Disable SSL verification (Dev only) false"},{"location":"rangereader/user-guide/configuration/#stack-recommendations","title":"Stack Recommendations","text":""},{"location":"rangereader/user-guide/configuration/#for-tile-servers","title":"For Tile Servers","text":"<p>A tile server needs low latency. Stack memory caching on top of disk caching.</p> <pre><code>// 1. Base S3 Reader\nvar base = S3RangeReader.builder().uri(uri).build();\n\n// 2. Disk Cache (Persistent L2)\nvar l2 = DiskCachingRangeReader.builder(base)\n    .cacheDirectory(cacheDir)\n    .maxCacheSizeBytes(50_000_000_000L) // 50GB\n    .build();\n\n// 3. Memory Cache (Fast L1)\nvar reader = CachingRangeReader.builder(l2)\n    .maximumSize(10_000) // Keep hot tiles in RAM\n    .softValues()        // Let JVM reclaim memory if needed\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/configuration/#for-data-pipelines-etl","title":"For Data Pipelines (ETL)","text":"<p>ETL jobs often read large chunks sequentially. Memory caching is less useful; focusing on throughput is key.</p> <pre><code>var reader = DiskCachingRangeReader.builder(base)\n    .maxCacheSizeBytes(1_000_000_000L) // 1GB buffer\n    .deleteOnClose()                   // Clean up after job\n    .build();\n</code></pre>"},{"location":"rangereader/user-guide/installation/","title":"Installation","text":"<p>This guide explains how to add the Tileverse Range Reader library to your Java project.</p>"},{"location":"rangereader/user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Java 17+: Minimum runtime version</li> <li>Maven 3.9+ or Gradle 7.0+: For dependency management</li> </ul>"},{"location":"rangereader/user-guide/installation/#maven-installation","title":"Maven Installation","text":""},{"location":"rangereader/user-guide/installation/#using-the-bom-recommended","title":"Using the BOM (Recommended)","text":"<p>The project provides a Bill of Materials (BOM) to manage dependency versions:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n    &lt;!-- Now you can omit versions - they're managed by the BOM --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Add cloud provider modules as needed --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n        &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#all-modules-simple-approach","title":"All Modules (Simple Approach)","text":"<p>Include all functionality with a single dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-all&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>No More Netty Conflicts</p> <p>A major benefit of this library is that the <code>s3</code> and <code>azure</code> modules can be used together without causing <code>netty</code> dependency conflicts.</p> <p>Historically, using the AWS and Azure Java SDKs in the same project was challenging because they relied on incompatible versions of Netty. This library solves that problem by using alternative HTTP clients (Apache HttpClient for S3, <code>java.net.HttpClient</code> for Azure), removing Netty entirely. You can now build multi-cloud applications without complex dependency management.</p>"},{"location":"rangereader/user-guide/installation/#individual-modules-without-bom","title":"Individual Modules (Without BOM)","text":"<p>If you prefer not to use the BOM, specify versions explicitly:</p>"},{"location":"rangereader/user-guide/installation/#core-module-required","title":"Core Module (Required)","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-core&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#cloud-provider-modules","title":"Cloud Provider Modules","text":"Amazon S3Azure Blob StorageGoogle Cloud Storage <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-azure&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-gcs&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#dependency-management-boms","title":"Dependency Management BOMs","text":"<p>The project provides two BOMs for different use cases:</p>"},{"location":"rangereader/user-guide/installation/#tileverse-bom","title":"Tileverse BOM","text":"<p>Manages versions of all Tileverse Range Reader modules:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>"},{"location":"rangereader/user-guide/installation/#dependencies-bom","title":"Dependencies BOM","text":"<p>Manages versions of third-party dependencies (for library developers):</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.tileverse&lt;/groupId&gt;\n            &lt;artifactId&gt;tileverse-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre> <p>This BOM includes managed versions for:</p> <ul> <li>AWS SDK components</li> <li>Azure Storage SDK components  </li> <li>Google Cloud Storage SDK components</li> <li>Jackson (JSON processing)</li> <li>Caffeine (caching)</li> </ul>"},{"location":"rangereader/user-guide/installation/#gradle-installation","title":"Gradle Installation","text":""},{"location":"rangereader/user-guide/installation/#using-the-bom-recommended_1","title":"Using the BOM (Recommended)","text":"<pre><code>dependencyManagement {\n    imports {\n        mavenBom 'io.tileverse:tileverse-bom:1.0-SNAPSHOT'\n    }\n}\n\ndependencies {\n    // Versions managed by the BOM\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-core'\n    implementation 'io.tileverse.rangereader:tileverse-rangereader-s3'\n}\n</code></pre>"},{"location":"rangereader/user-guide/installation/#all-modules","title":"All Modules","text":"<pre><code>implementation 'io.tileverse.rangereader:tileverse-rangereader-all:1.0-SNAPSHOT'\n</code></pre>"},{"location":"rangereader/user-guide/installation/#individual-modules","title":"Individual Modules","text":"<pre><code>// Core module (required)\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-core:1.0-SNAPSHOT'\n\n// Cloud provider modules (optional)\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-s3:1.0-SNAPSHOT'\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-azure:1.0-SNAPSHOT'\nimplementation 'io.tileverse.rangereader:tileverse-rangereader-gcs:1.0-SNAPSHOT'\n</code></pre>"},{"location":"rangereader/user-guide/installation/#version-compatibility","title":"Version Compatibility","text":"Library Version Java Version Maven Version 1.0.x 17+ 3.9+"},{"location":"rangereader/user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test to verify the installation:</p> <pre><code>import io.tileverse.rangereader.FileRangeReader;\nimport java.nio.file.Path;\nimport java.nio.file.Files;\n\npublic class InstallationTest {\n    public static void main(String[] args) throws Exception {\n        // Create a temporary test file\n        Path testFile = Files.createTempFile(\"test\", \".bin\");\n        Files.write(testFile, \"Hello, World!\".getBytes());\n\n        // Test the library\n        try (var reader = FileRangeReader.builder()\n                .path(testFile)\n                .build()) {\n\n            var data = reader.readRange(0, 5);\n            data.flip();\n            String result = new String(data.array(), 0, data.remaining());\n            System.out.println(\"Read: \" + result); // Should print \"Hello\"\n\n            System.out.println(\"Installation successful!\");\n        }\n\n        // Clean up\n        Files.deleteIfExists(testFile);\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/installation/#migration-guide","title":"Migration Guide","text":""},{"location":"rangereader/user-guide/installation/#from-other-range-reading-libraries","title":"From Other Range Reading Libraries","text":"<p>Common migration patterns:</p> <ul> <li>Map offset/length operations to <code>readRange()</code> calls</li> <li>Replace custom caching with built-in decorators  </li> <li>Adopt builder patterns for configuration instead of constructors</li> </ul>"},{"location":"rangereader/user-guide/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Basic usage examples</li> <li>Configuration: Performance optimization</li> <li>Authentication: Cloud provider setup</li> </ul>"},{"location":"rangereader/user-guide/quick-start/","title":"Quick Start","text":"<p>Get started with the Tileverse Range Reader library in minutes with these basic examples.</p>"},{"location":"rangereader/user-guide/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"rangereader/user-guide/quick-start/#reading-from-local-files","title":"Reading from Local Files","text":"<pre><code>import io.tileverse.rangereader.FileRangeReader;\nimport java.nio.ByteBuffer;\nimport java.nio.file.Path;\n\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"data.bin\"))\n        .build()) {\n\n    // Read first 1024 bytes\n    ByteBuffer header = reader.readRange(0, 1024);\n    header.flip(); // Prepare buffer for reading\n\n    // Read a specific section\n    ByteBuffer chunk = reader.readRange(50000, 8192);\n    chunk.flip(); // Prepare buffer for reading\n\n    // Get total file size\n    long size = reader.size();\n\n    System.out.println(\"File size: \" + size + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#reading-from-http","title":"Reading from HTTP","text":"<pre><code>import io.tileverse.rangereader.HttpRangeReader;\nimport java.net.URI;\n\ntry (var reader = HttpRangeReader.builder()\n        .uri(URI.create(\"https://example.com/data.bin\"))\n        .build()) {\n\n    // Read range from remote file\n    ByteBuffer data = reader.readRange(1000, 500);\n    data.flip(); // Prepare buffer for reading\n\n    System.out.println(\"Read \" + data.remaining() + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#reading-from-amazon-s3","title":"Reading from Amazon S3","text":"<pre><code>import io.tileverse.rangereader.s3.S3RangeReader;\nimport software.amazon.awssdk.regions.Region;\nimport java.net.URI;\n\ntry (var reader = S3RangeReader.builder()\n        .uri(URI.create(\"s3://my-bucket/data.bin\"))\n        .region(Region.US_WEST_2)\n        .build()) {\n\n    // Read from S3 object\n    ByteBuffer data = reader.readRange(0, 1024);\n    data.flip();\n\n    System.out.println(\"Read from S3: \" + data.remaining() + \" bytes\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#performance-optimization","title":"Performance Optimization","text":""},{"location":"rangereader/user-guide/quick-start/#adding-memory-caching","title":"Adding Memory Caching","text":"<p>Memory caching is most beneficial for cloud storage where network latency is significant:</p> <pre><code>import io.tileverse.rangereader.cache.CachingRangeReader;\n\n// Use caching with cloud storage for maximum benefit\nvar baseReader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://my-bucket/large-file.bin\"))\n    .region(Region.US_WEST_2)\n    .build();\n\ntry (var cachedReader = CachingRangeReader.builder(baseReader)\n        .maximumSize(1000)  // Cache up to 1000 ranges\n        .build()) {\n\n    // First read - network request to S3\n    ByteBuffer data1 = cachedReader.readRange(0, 1024);\n    data1.flip();\n\n    // Second read - served from cache (much faster, no network)\n    ByteBuffer data2 = cachedReader.readRange(0, 1024);\n    data2.flip();\n}\n</code></pre> <p>Note: For local files, caching provides little benefit since the OS already caches file data efficiently.</p>"},{"location":"rangereader/user-guide/quick-start/#disk-caching-for-large-datasets","title":"Disk Caching for Large Datasets","text":"<pre><code>import io.tileverse.rangereader.cache.DiskCachingRangeReader;\n\nvar s3Reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/large-file.bin\"))\n    .build();\n\ntry (var cachedReader = DiskCachingRangeReader.builder(s3Reader)\n        .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB cache\n        .build()) {\n\n    // Reads are cached to disk for persistence across sessions\n    ByteBuffer data = cachedReader.readRange(100, 500);\n    data.flip();\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>// Optimal configuration for cloud storage\ntry (var optimizedReader = CachingRangeReader.builder(\n        DiskCachingRangeReader.builder(\n            S3RangeReader.builder()\n                .uri(URI.create(\"s3://bucket/data.bin\"))\n                .build())\n            .maxCacheSizeBytes(10L * 1024 * 1024 * 1024)  // 10GB disk cache\n            .build())\n        .maximumSize(1000)  // 1000 entries in memory\n        .build()) {\n\n    // Highly optimized reads with multiple caching layers\n    ByteBuffer data = optimizedReader.readRange(offset, length);\n    data.flip(); // Prepare buffer for reading\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#working-with-bytebuffers","title":"Working with ByteBuffers","text":""},{"location":"rangereader/user-guide/quick-start/#reusing-buffers-recommended","title":"Reusing Buffers (Recommended)","text":"<pre><code>// Efficient: Reuse the same buffer\nByteBuffer buffer = ByteBuffer.allocate(8192);\n\nfor (long offset = 0; offset &lt; fileSize; offset += 8192) {\n    buffer.clear();  // Reset for writing\n\n    int bytesRead = reader.readRange(offset, 8192, buffer);\n    buffer.flip(); // Prepare buffer for reading\n\n    // Process buffer contents\n    processData(buffer);\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#direct-buffers-for-large-reads","title":"Direct Buffers for Large Reads","text":"<pre><code>// For large reads, use direct buffers\nByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);\n\ntry {\n    int bytesRead = reader.readRange(0, 1024 * 1024, directBuffer);\n    directBuffer.flip();\n\n    // Process large chunk efficiently\n    processLargeData(directBuffer);\n} finally {\n    // Clean up direct buffer if needed\n    if (directBuffer.isDirect()) {\n        ((DirectBuffer) directBuffer).cleaner().clean();\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>import java.io.IOException;\n\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"data.bin\"))\n        .build()) {\n\n    // Validate before reading\n    long fileSize = reader.size();\n    long offset = 1000;\n    int length = 500;\n\n    if (offset &gt;= fileSize) {\n        System.out.println(\"Offset beyond file end\");\n        return;\n    }\n\n    // Adjust length if it extends beyond EOF\n    if (offset + length &gt; fileSize) {\n        length = (int) (fileSize - offset);\n    }\n\n    ByteBuffer data = reader.readRange(offset, length);\n    data.flip(); // Prepare buffer for reading\n\n} catch (IOException e) {\n    System.err.println(\"Failed to read data: \" + e.getMessage());\n} catch (IllegalArgumentException e) {\n    System.err.println(\"Invalid parameters: \" + e.getMessage());\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"rangereader/user-guide/quick-start/#reading-file-headers","title":"Reading File Headers","text":"<pre><code>// Read different header formats\ntry (var reader = FileRangeReader.builder()\n        .path(Path.of(\"image.tiff\"))\n        .build()) {\n\n    // Read TIFF header\n    ByteBuffer header = reader.readRange(0, 16);\n    header.flip(); // Prepare buffer for reading\n\n    // Check magic number\n    short magic = header.getShort();\n\n    if (magic == 0x4949 || magic == 0x4D4D) {\n        System.out.println(\"Valid TIFF file\");\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#streaming-large-files","title":"Streaming Large Files","text":"<pre><code>// Process large files in chunks\npublic void processLargeFile(Path filePath, int chunkSize) throws IOException {\n    try (var reader = FileRangeReader.builder()\n            .path(filePath)\n            .build()) {\n\n        long fileSize = reader.size();\n        long processed = 0;\n\n        while (processed &lt; fileSize) {\n            int currentChunkSize = (int) Math.min(chunkSize, fileSize - processed);\n\n            ByteBuffer chunk = reader.readRange(processed, currentChunkSize);\n            chunk.flip(); // Prepare buffer for reading\n\n            // Process this chunk\n            processChunk(chunk);\n\n            processed += currentChunkSize;\n\n            // Report progress\n            double progress = (double) processed / fileSize * 100;\n            System.out.printf(\"Progress: %.1f%%\\n\", progress);\n        }\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration: Learn about performance tuning</li> <li>Authentication: Set up cloud provider access</li> <li>Troubleshooting: Common issues and solutions</li> </ul>"},{"location":"rangereader/user-guide/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions when using the Tileverse Range Reader library.</p>"},{"location":"rangereader/user-guide/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>Problem: Maven/Gradle dependency conflicts with AWS, Azure, or Google Cloud SDKs.</p> <p>Solution: Use the BOM (Bill of Materials) for version alignment:</p> <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- AWS BOM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;\n            &lt;artifactId&gt;bom&lt;/artifactId&gt;\n            &lt;version&gt;2.31.70&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- Azure BOM --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.azure&lt;/groupId&gt;\n            &lt;artifactId&gt;azure-sdk-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.2.28&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#java-version-issues","title":"Java Version Issues","text":"<p>Problem: <code>UnsupportedClassVersionError</code> or similar Java version errors.</p> <p>Solution: Ensure you're using Java 17 or higher:</p> <pre><code>java -version\n# Should show version 17 or higher\n\n# Set JAVA_HOME if needed\nexport JAVA_HOME=/path/to/java17\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#missing-module-errors","title":"Missing Module Errors","text":"<p>Problem: <code>ClassNotFoundException</code> for cloud provider classes.</p> <p>Solution: Include the specific module dependency:</p> <pre><code>&lt;!-- For S3 support --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.rangereader&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-rangereader-s3&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#aws-s3-authentication","title":"AWS S3 Authentication","text":"<p>Problem: <code>SdkClientException: Unable to load AWS credentials</code></p> <p>Solutions:</p> <ol> <li> <p>Set environment variables:    <pre><code>export AWS_ACCESS_KEY_ID=your-access-key\nexport AWS_SECRET_ACCESS_KEY=your-secret-key\nexport AWS_DEFAULT_REGION=us-west-2\n</code></pre></p> </li> <li> <p>Create AWS credentials file:    <pre><code>mkdir -p ~/.aws\ncat &gt; ~/.aws/credentials &lt;&lt; EOF\n[default]\naws_access_key_id = your-access-key\naws_secret_access_key = your-secret-key\nEOF\n</code></pre></p> </li> <li> <p>Use IAM role (on EC2/ECS):    <pre><code>// No explicit credentials needed - uses instance profile\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .region(Region.US_WEST_2)\n    .build();\n</code></pre></p> </li> </ol> <p>Problem: <code>S3Exception: Access Denied (Service: S3, Status Code: 403)</code></p> <p>Solutions:</p> <ol> <li> <p>Check bucket permissions:    <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\"s3:GetObject\"],\n      \"Resource\": \"arn:aws:s3:::your-bucket/*\"\n    }\n  ]\n}\n</code></pre></p> </li> <li> <p>Verify object exists:    <pre><code>aws s3 ls s3://your-bucket/your-key\n</code></pre></p> </li> <li> <p>Check region:    <pre><code>// Ensure region matches bucket region\nvar reader = S3RangeReader.builder()\n    .uri(URI.create(\"s3://bucket/key\"))\n    .region(Region.US_WEST_2)  // Correct region\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#azure-blob-storage-authentication","title":"Azure Blob Storage Authentication","text":"<p>Problem: <code>BlobStorageException: AuthenticationFailed</code></p> <p>Solutions:</p> <ol> <li> <p>Verify connection string:    <pre><code>var connectionString = \"DefaultEndpointsProtocol=https;\" +\n    \"AccountName=youraccount;\" +\n    \"AccountKey=yourkey;\" +\n    \"EndpointSuffix=core.windows.net\";\n</code></pre></p> </li> <li> <p>Check SAS token expiration:    <pre><code># Decode SAS token to check expiry\necho \"sv=2020-08-04&amp;se=2024-12-31...\" | base64 -d\n</code></pre></p> </li> <li> <p>Test connectivity:    <pre><code>az storage blob list --account-name youraccount --container-name yourcontainer\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#google-cloud-storage-authentication","title":"Google Cloud Storage Authentication","text":"<p>Problem: <code>GoogleCloudStorageException: 403 Forbidden</code></p> <p>Solutions:</p> <ol> <li> <p>Set service account key:    <pre><code>export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json\n</code></pre></p> </li> <li> <p>Test authentication:    <pre><code>gcloud auth application-default login\ngsutil ls gs://your-bucket/\n</code></pre></p> </li> <li> <p>Check service account permissions:    <pre><code>gcloud projects get-iam-policy your-project-id\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#slow-read-performance","title":"Slow Read Performance","text":"<p>Problem: Range reads are slower than expected.</p> <p>Solutions:</p> <ol> <li> <p>Enable caching:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(1000)\n    .build();\n</code></pre></p> </li> <li> <p>Use disk caching for persistent storage:    <pre><code>// For large datasets, use disk caching\nvar reader = DiskCachingRangeReader.builder(cloudReader)\n    .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB cache\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Problem: Application uses too much memory.</p> <p>Solutions:</p> <ol> <li> <p>Use soft references in cache:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .softValues()  // Allow GC to reclaim memory\n    .build();\n</code></pre></p> </li> <li> <p>Limit cache size:    <pre><code>var reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(100)  // Limit entries\n    .maxSizeBytes(64 * 1024 * 1024)  // 64MB limit\n    .build();\n</code></pre></p> </li> <li> <p>Use disk caching instead:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .maxCacheSizeBytes(1024 * 1024 * 1024)  // 1GB on disk\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#cache-not-working","title":"Cache Not Working","text":"<p>Problem: Cache statistics show low hit rates.</p> <p>Solutions:</p> <ol> <li> <p>Check cache configuration:    <pre><code>if (reader instanceof CachingRangeReader cachingReader) {\n    var stats = cachingReader.getCacheStats();\n    System.out.println(\"Hit rate: \" + stats.hitRate());\n    System.out.println(\"Miss count: \" + stats.missCount());\n}\n</code></pre></p> </li> <li> <p>Ensure consistent read patterns:    <pre><code>// Good: Consistent block-aligned reads\nfor (int i = 0; i &lt; 10; i++) {\n    reader.readRange(i * 1024, 1024);  // Cache-friendly\n}\n\n// Bad: Random, unaligned reads\nreader.readRange(100, 500);   // Won't benefit from caching\nreader.readRange(1500, 300);\n</code></pre></p> </li> <li> <p>Use appropriate read patterns:    <pre><code>// Ensure consistent read patterns to improve cache hits\nvar reader = CachingRangeReader.builder(baseReader)\n    .maximumSize(1000)\n    .build();\n\n// Read in consistent chunks\nint chunkSize = 64 * 1024;  // 64KB chunks\nfor (int i = 0; i &lt; 10; i++) {\n    reader.readRange(i * chunkSize, chunkSize);  // Cache-friendly\n}\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#network-issues","title":"Network Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#connection-timeouts","title":"Connection Timeouts","text":"<p>Problem: <code>SocketTimeoutException</code> or connection timeouts.</p> <p>Solutions:</p> <ol> <li> <p>Increase timeouts:    <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .connectTimeout(Duration.ofSeconds(30))\n    .readTimeout(Duration.ofMinutes(5))\n    .build();\n</code></pre></p> </li> <li> <p>Configure retries:    <pre><code>var reader = HttpRangeReader.builder()\n    .uri(uri)\n    .maxRetries(3)\n    .retryDelay(Duration.ofSeconds(1))\n    .build();\n</code></pre></p> </li> <li> <p>For S3, configure client:    <pre><code>var s3Client = S3Client.builder()\n    .overrideConfiguration(ClientOverrideConfiguration.builder()\n        .apiCallTimeout(Duration.ofMinutes(2))\n        .apiCallAttemptTimeout(Duration.ofSeconds(30))\n        .build())\n    .build();\n\nvar reader = S3RangeReader.builder()\n    .client(s3Client)\n    .bucket(\"bucket\")\n    .key(\"key\")\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#proxy-configuration","title":"Proxy Configuration","text":"<p>Problem: Cannot connect through corporate proxy.</p> <p>Solutions:</p> <ol> <li> <p>Set system properties:    <pre><code>-Dhttp.proxyHost=proxy.company.com\n-Dhttp.proxyPort=8080\n-Dhttps.proxyHost=proxy.company.com\n-Dhttps.proxyPort=8080\n</code></pre></p> </li> <li> <p>Configure AWS SDK proxy:    <pre><code>var proxyConfig = ProxyConfiguration.builder()\n    .endpoint(URI.create(\"http://proxy.company.com:8080\"))\n    .username(\"proxyuser\")\n    .password(\"proxypass\")\n    .build();\n\nvar s3Client = S3Client.builder()\n    .overrideConfiguration(ClientOverrideConfiguration.builder()\n        .proxyConfiguration(proxyConfig)\n        .build())\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#ssltls-issues","title":"SSL/TLS Issues","text":"<p>Problem: SSL certificate validation errors.</p> <p>Solutions:</p> <ol> <li> <p>For development only - disable SSL verification:    <pre><code>// NOT recommended for production\nvar reader = HttpRangeReader.builder()\n    .uri(uri)\n    .trustAllCertificates(true)\n    .build();\n</code></pre></p> </li> <li> <p>Add custom certificate to truststore:    <pre><code>keytool -import -alias custom-cert -file cert.crt -keystore $JAVA_HOME/lib/security/cacerts\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#file-system-issues","title":"File System Issues","text":""},{"location":"rangereader/user-guide/troubleshooting/#file-access-permissions","title":"File Access Permissions","text":"<p>Problem: <code>AccessDeniedException</code> when reading local files.</p> <p>Solutions:</p> <ol> <li> <p>Check file permissions:    <pre><code>ls -la /path/to/file\nchmod 644 /path/to/file  # Make readable\n</code></pre></p> </li> <li> <p>Verify file exists:    <pre><code>Path filePath = Path.of(\"/path/to/file\");\nif (!Files.exists(filePath)) {\n    throw new FileNotFoundException(\"File not found: \" + filePath);\n}\nif (!Files.isReadable(filePath)) {\n    throw new IOException(\"File not readable: \" + filePath);\n}\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#disk-cache-issues","title":"Disk Cache Issues","text":"<p>Problem: Disk cache not working or filling up disk.</p> <p>Solutions:</p> <ol> <li> <p>Check disk space:    <pre><code>df -h /tmp/rangereader-cache\n</code></pre></p> </li> <li> <p>Configure cache location:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .cacheDirectory(\"/var/cache/rangereader\")  // Custom location\n    .maxCacheSizeBytes(5L * 1024 * 1024 * 1024)  // 5GB limit\n    .build();\n</code></pre></p> </li> <li> <p>Enable cleanup on close:    <pre><code>var reader = DiskCachingRangeReader.builder(baseReader)\n    .deleteOnClose()  // Clean up when done\n    .build();\n</code></pre></p> </li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"rangereader/user-guide/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>// Add to your application startup\nSystem.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", \"DEBUG\");\nSystem.setProperty(\"org.slf4j.simpleLogger.log.io.tileverse.rangereader\", \"DEBUG\");\n\n// For AWS SDK\nSystem.setProperty(\"org.slf4j.simpleLogger.log.software.amazon.awssdk\", \"DEBUG\");\n\n// For Azure SDK\nSystem.setProperty(\"org.slf4j.simpleLogger.log.com.azure\", \"DEBUG\");\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#monitor-cache-performance","title":"Monitor Cache Performance","text":"<pre><code>public void monitorCache(RangeReader reader) {\n    if (reader instanceof CachingRangeReader cachingReader) {\n        var stats = cachingReader.getCacheStats();\n\n        System.out.println(\"Cache Statistics:\");\n        System.out.println(\"  Hit Rate: \" + String.format(\"%.2f%%\", stats.hitRate() * 100));\n        System.out.println(\"  Requests: \" + stats.requestCount());\n        System.out.println(\"  Hits: \" + stats.hitCount());\n        System.out.println(\"  Misses: \" + stats.missCount());\n        System.out.println(\"  Evictions: \" + stats.evictionCount());\n        System.out.println(\"  Size: \" + stats.estimatedSize());\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#test-connectivity","title":"Test Connectivity","text":"<pre><code>public void testConnectivity(URI uri) {\n    try {\n        var reader = createReader(uri);\n        long size = reader.size();\n        System.out.println(\"Successfully connected to \" + uri + \", size: \" + size);\n        reader.close();\n    } catch (Exception e) {\n        System.err.println(\"Failed to connect to \" + uri + \": \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#profile-performance","title":"Profile Performance","text":"<pre><code>public void profileReads(RangeReader reader) {\n    int numReads = 100;\n    int blockSize = 64 * 1024;\n\n    long startTime = System.nanoTime();\n\n    for (int i = 0; i &lt; numReads; i++) {\n        try {\n            reader.readRange(i * blockSize, blockSize);\n        } catch (IOException e) {\n            System.err.println(\"Read failed at offset \" + (i * blockSize));\n        }\n    }\n\n    long endTime = System.nanoTime();\n    double durationMs = (endTime - startTime) / 1_000_000.0;\n\n    System.out.println(\"Read \" + numReads + \" blocks in \" + durationMs + \"ms\");\n    System.out.println(\"Average: \" + (durationMs / numReads) + \"ms per read\");\n}\n</code></pre>"},{"location":"rangereader/user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check the logs for detailed error messages</li> <li>Search GitHub issues for similar problems</li> <li>Create a minimal reproduction case</li> <li>Submit an issue with:</li> <li>Library version</li> <li>Java version</li> <li>Operating system</li> <li>Complete error message and stack trace</li> <li>Minimal code example</li> </ol>"},{"location":"rangereader/user-guide/troubleshooting/#common-error-messages","title":"Common Error Messages","text":"Error Likely Cause Solution <code>ClassNotFoundException</code> Missing module dependency Add required module to dependencies <code>Access Denied (403)</code> Authentication/authorization Check credentials and permissions <code>NoSuchFileException</code> File not found Verify file/object exists <code>SocketTimeoutException</code> Network timeout Increase timeout or check connectivity <code>OutOfMemoryError</code> Large cache or buffer usage Reduce cache size or use disk caching <code>UnsupportedClassVersionError</code> Wrong Java version Use Java 17 or higher"},{"location":"tilematrixset/","title":"Tile Matrix Set","text":"<p>A Java implementation of the OGC Two-Phase Tile Matrix Set (TMS) standard. This library handles the mathematical complexity of tile pyramids, coordinate systems, and grid definitions.</p>"},{"location":"tilematrixset/#features","title":"Features","text":"<ul> <li>OGC Compliance: Implements the data model for Tile Matrix Sets.</li> <li>Standard Sets: Includes built-in definitions for <code>WebMercatorQuad</code> and <code>WorldCRS84Quad</code>.</li> <li>Math Utilities: Helper functions for converting between bounding boxes, geographic coordinates, and tile indices.</li> </ul>"},{"location":"tilematrixset/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.tilematrixset&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-tilematrixset&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tilematrixset/#usage","title":"Usage","text":""},{"location":"tilematrixset/#working-with-coordinates","title":"Working with Coordinates","text":"<pre><code>import io.tileverse.tiling.matrix.DefaultTileMatrixSets;\n\nvar tms = DefaultTileMatrixSets.WEB_MERCATOR_QUAD;\nvar matrix = tms.tileMatrix(12); // Zoom level 12\n\n// Calculate which tiles cover a specific geographic area\nvar bbox = new BoundingBox2D(-74.0, 40.7, -73.9, 40.8); // NYC\nvar tileRange = matrix.getTilesIntersecting(bbox);\n\nSystem.out.println(\"Tiles needed: \" + tileRange.size());\nfor (var tile : tileRange) {\n    System.out.printf(\"Fetch z=%d x=%d y=%d%n\", 12, tile.x(), tile.y());\n}\n</code></pre>"},{"location":"tilematrixset/user-guide/","title":"Tile Matrix Set User Guide","text":"<p>Learn how to work with tile pyramids and matrix sets.</p>"},{"location":"tilematrixset/user-guide/#installation","title":"Installation","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.tilematrixset&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-tilematrixset&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.tileverse.tilematrixset:tileverse-tilematrixset:1.1-SNAPSHOT'\n</code></pre>"},{"location":"tilematrixset/user-guide/#topics","title":"Topics","text":"<ul> <li>Quick Start</li> <li>Tile Pyramids</li> <li>Standard Sets</li> </ul>"},{"location":"tilematrixset/user-guide/quick-start/","title":"Quick Start","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"tilematrixset/user-guide/standard-sets/","title":"Standard Sets","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"tilematrixset/user-guide/tile-pyramids/","title":"Tile Pyramids","text":"<p>Coming Soon</p> <p>Detailed documentation is under development.</p>"},{"location":"vectortiles/","title":"Vector Tiles","text":"<p>A high-performance library for encoding and decoding Mapbox Vector Tiles (MVT) in Java. It bridges the gap between raw Protocol Buffers data and usable Java objects (JTS Geometries).</p>"},{"location":"vectortiles/#capabilities","title":"Capabilities","text":"<ul> <li>MVT v2.1 Compliance: Full support for layers, features, and values.</li> <li>JTS Integration: Direct conversion between MVT geometry commands and JTS <code>Geometry</code> objects.</li> <li>Zero-Copy Decoding: Optimized parsing strategies to minimize object allocation during reads.</li> </ul>"},{"location":"vectortiles/#installation","title":"Installation","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.vectortiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-vectortiles&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"vectortiles/#usage","title":"Usage","text":""},{"location":"vectortiles/#decoding","title":"Decoding","text":"<p>Convert raw MVT bytes (e.g., from a PMTiles archive or network request) into a structured Java object.</p> <pre><code>import io.tileverse.vectortile.mvt.VectorTileCodec;\n\nbyte[] rawBytes = ...; // your MVT data\n\nvar codec = VectorTileCodec.getDefault();\nvar tile = codec.decode(rawBytes);\n\nfor (var layer : tile.getLayers()) {\n    System.out.println(\"Layer: \" + layer.getName());\n\n    for (var feature : layer.getFeatures()) {\n        // Access JTS Geometry directly\n        org.locationtech.jts.geom.Geometry geom = feature.getGeometry();\n        Map&lt;String, Object&gt; props = feature.getAttributes();\n    }\n}\n</code></pre>"},{"location":"vectortiles/#encoding","title":"Encoding","text":"<p>Create MVTs from scratch using JTS geometries.</p> <pre><code>import io.tileverse.vectortile.mvt.VectorTileBuilder;\n\nvar builder = VectorTileBuilder.create();\nvar layer = builder.layer(\"buildings\");\n\nlayer.feature()\n     .id(123)\n     .geometry(jtsPolygon)\n     .attribute(\"height\", 50)\n     .attribute(\"type\", \"residential\");\n\nbyte[] encoded = codec.encode(builder.build());\n</code></pre>"},{"location":"vectortiles/user-guide/","title":"Vector Tiles User Guide","text":"<p>Welcome to the Tileverse Vector Tiles User Guide.</p>"},{"location":"vectortiles/user-guide/#overview","title":"Overview","text":"<p>This guide covers encoding and decoding Mapbox Vector Tiles (MVT) in Java.</p>"},{"location":"vectortiles/user-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17 or newer</li> <li>Basic understanding of vector tiles and tiled mapping</li> </ul>"},{"location":"vectortiles/user-guide/#installation","title":"Installation","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.tileverse.vectortiles&lt;/groupId&gt;\n    &lt;artifactId&gt;tileverse-vectortiles&lt;/artifactId&gt;\n    &lt;version&gt;1.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.tileverse.vectortiles:tileverse-vectortiles:1.1-SNAPSHOT'\n</code></pre>"},{"location":"vectortiles/user-guide/#topics","title":"Topics","text":"<ul> <li>Quick Start: Get started quickly</li> <li>Encoding Tiles: Create MVT tiles</li> <li>Decoding Tiles: Read MVT tiles</li> </ul>"},{"location":"vectortiles/user-guide/#next-steps","title":"Next Steps","text":"<p>Start with the Quick Start guide.</p>"},{"location":"vectortiles/user-guide/decoding/","title":"Decoding Vector Tiles","text":"<p>Coming Soon</p> <p>Detailed decoding documentation is under development.</p> <p>See Quick Start for basic examples.</p>"},{"location":"vectortiles/user-guide/encoding/","title":"Encoding Vector Tiles","text":"<p>Coming Soon</p> <p>Detailed encoding documentation is under development.</p> <p>See Quick Start for basic examples.</p>"},{"location":"vectortiles/user-guide/quick-start/","title":"Vector Tiles Quick Start","text":"<p>Get started with Tileverse Vector Tiles quickly.</p>"},{"location":"vectortiles/user-guide/quick-start/#decoding-mvt","title":"Decoding MVT","text":"<pre><code>import io.tileverse.vectortile.mvt.VectorTileCodec;\nimport io.tileverse.vectortile.model.VectorTile;\n\nVectorTileCodec codec = VectorTileCodec.getDefault();\nbyte[] mvtBytes = ...; // Load from file, network, etc.\n\nVectorTile tile = codec.decode(mvtBytes);\n\n// Iterate layers and features\nfor (VectorTile.Layer layer : tile.getLayers()) {\n    System.out.println(\"Layer: \" + layer.getName());\n    for (VectorTile.Layer.Feature feature : layer.getFeatures()) {\n        System.out.println(\"  Feature ID: \" + feature.getId());\n        System.out.println(\"  Geometry: \" + feature.getGeometry());\n        System.out.println(\"  Attributes: \" + feature.getAttributes());\n    }\n}\n</code></pre>"},{"location":"vectortiles/user-guide/quick-start/#encoding-mvt","title":"Encoding MVT","text":"<pre><code>import io.tileverse.vectortile.mvt.VectorTileBuilder;\n\nVectorTileBuilder builder = VectorTileBuilder.create();\n\nbuilder.layer(\"poi\")\n    .feature()\n        .geometry(point)\n        .attributes(Map.of(\"name\", \"Restaurant\"));\n\nVectorTile tile = builder.build();\nbyte[] mvtBytes = codec.encode(tile);\n</code></pre>"},{"location":"vectortiles/user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Encoding Tiles</li> <li>Decoding Tiles</li> </ul>"}]}